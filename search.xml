<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Windows程序乱码问题【待更新】</title>
    <url>//posts/10bd7559/</url>
    <content><![CDATA[<div class="note danger flat"><p>本博客在测试阶段不够严谨，后期安排将使用 C++ 以及 C++  标准库中的本地化库进行测试。</p>
</div>
<h2 id="一、-前言">一、 前言</h2>
<h3 id="1-问题描述">1. 问题描述</h3>
<p>作为非英语国家的Windows用户，在Windows上进行编程想必都会遇到一个问题：中文乱码的问题。当然不只是中文，还有其他很多非英文国家也都有这个问题，这里仅以中文为例。</p>
<p>另外，乱码还有很多种类型，如常见的“锟斤拷”、“火星文”乱码等，它们的引发原因都是不同的。以及程序运行时还分为输入乱码以及输出乱码。我将对其进行详细的讨论。</p>
<h3 id="2-目标">2. 目标</h3>
<p>程序是程序员写的，是写给用户用的。我们需要抓住这里面的两个主要对象：</p>
<ul>
<li>
<p>用户：用户只想要以最轻松的方法就能正常使用软件，就像我们使用软件时只需要打开一个exe文件就可以了，一切复杂的操作都不要留给用户。</p>
<blockquote>
<p>这里一定要说的是：网络上有很多方法可以解决乱码问题，比如将Windows调成Beta版、终端在运行前通过chcp修改代码页或者是去注册表里修改终端的代码页属性等，这些工作做了确实有一定的效果（甚至有些效果都不完全），但是有哪个用户希望在使用你这个软件的时候去改这改那的，甚至还会影响到其他软件的运行。</p>
</blockquote>
</li>
<li>
<p>程序员：只想以最小的工作量完成需要的功能。</p>
<blockquote>
<p>为了解决乱码问题，我们当然可以将源文件就直接保存为GBK编码，然后编译的时候也按照GBK编译，最后的程序运行在GBK终端上，这样的方式当然是可以解决乱码问题，但是这样的程序只能给默认使用GBK编码的Windows系统的用户使用。为了使软件走向国际化，你还得为每一个有特殊代码页的国家编译一次甚至还得修改代码，最后让用户来选自己应该下载哪一个版本。这样既麻烦了程序员，又为用户带来了不必要的麻烦。</p>
<p>为了解决这个问题，我们可以使用Unicode编码，它可以表示全世界正在使用的所有字符并且还有空余位置。其中 UTF-8 编码应用最广，因为在所有Unicode编码中，只有UTF-8保证了除了空字符外，其余字符都不含0字节（这对使用C语言编程的程序比较友好，因为C语言程序通常以0字节表示字符串终止，如果在其他字符中包含0字节，可想而知，程序会将其自动识别为已终止，但实际上内容还没完）。</p>
</blockquote>
</li>
</ul>
<p>综上所述，我们最主要的一个目标就是如何编写一个UTF-8编码的程序并让其在任何终端环境都能正常运行。</p>
<h3 id="3-测试程序">3. 测试程序</h3>
<p>我们的测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你刚刚的输入是：%s\n&quot;</span>, name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序中既涉及到了输入，也涉及到了输出，我们可以同时测试两种类型的乱码，并根据乱码的类型来判断原因。</p>
<h3 id="4-影响因素">4. 影响因素</h3>
<p>在从源文件到软件程序的过程中，有几个因素都会影响最终程序的乱码与否，我们通过两个编译器来看比较典型的两个过程：</p>
<h4 id="1）MSVC编译器">1）MSVC编译器</h4>
<p>这是Visual Studio配套的一个编译器，如果不做任何修改，它的一个编译过程如下：</p>
<p><img src="/images/Windows%E7%8E%AF%E5%A2%83%E7%A8%8B%E5%BA%8F%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/01.jpg" alt="01"></p>
<p>其运行结果如下：</p>
<p><img src="/images/Windows%E7%8E%AF%E5%A2%83%E7%A8%8B%E5%BA%8F%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/02.png" alt="02"></p>
<p>所以在默认情况下，我们使用Visual Studio生成的程序可以完美地在自己的机器上执行。但由于其产生的目标程序使用GBK编码，而我们并不希望如此。</p>
<h4 id="2）GCC编译器">2）GCC编译器</h4>
<p>除了MSVC是默认使用GBK编码源文件之外，其他编译器基本上都是使用的UTF-8编码，不一定是GCC，但它比较有代表性，其典型过程如下图所示：</p>
<p><img src="/images/Windows%E7%8E%AF%E5%A2%83%E7%A8%8B%E5%BA%8F%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/03.jpg" alt="03"></p>
<p>其运行结果如下：</p>
<p><img src="/images/Windows%E7%8E%AF%E5%A2%83%E7%A8%8B%E5%BA%8F%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/04.png" alt="04"></p>
<h4 id="3）总结">3）总结</h4>
<p>从这上面的两个例子我们可以看到以下几点：</p>
<ul>
<li>对于中文<strong>输入</strong>来说，程序的编码与终端的编码是否相同对结果并没有什么影响，这是因为程序只保存编码后的字节信息，然后输出时将字节信息发送给终端，中间并不会经过什么处理。如果我们要在程序中处理中文字符，一般就不使用<code>char</code>来保存字符信息了，而使用宽字符。</li>
<li>源文件编码、编译器编码以及程序运行的终端这三个方面的共同作用会决定最后的程序是否会出现乱码。</li>
</ul>
<h3 id="5-配置-Visual-Studio（可选）">5. 配置 Visual Studio（可选）</h3>
<p>回过头来看我们想要达到的目标，使用UTF-8编码编写程序，生成的程序中使用UTF-8编码保存字符及字符串，最后能在任何编码环境的终端上正确运行。</p>
<p>很显然，上面的第二种过程（GCC）比较适合我们要讨论的内容（虽然它的输出暂时有问题），后面也将主要使用这种方法来进行测试。但对于第一种过程（MSVC）也是可以调整成与第二种过程相同的。</p>
<p>对于仅开发面向于使用GBK编码的Windows用户的程序来说，当然使用其原本的配置就可以了，生成的程序也能完美的在这样的主机上运行。但如果是想使用UTF-8编码或者有软件国际化需求的程序员来说，也可以像下面这样将MSVC配置成与GCC编译（编码上）相同的过程：</p>
<h4 id="1）保证文件的编码">1）保证文件的编码</h4>
<p>我们首先需要做的就是保证文件的编码是UTF-8编码。</p>
<ul>
<li>
<p>第一步是开启查看当前的文件的编码的设置项</p>
<p>主要目标是开启【文件】菜单栏下的【高级保存选项】的选项。以下是操作过程（过程比较多就不用截图的方式了）：</p>
<p>【工具】-&gt;【自定义】-&gt;【命令】-&gt; 在【菜单栏】右侧的下拉框中选择【文件】-&gt;【添加命令】-&gt;【文件】-&gt; 在右侧找到【高级保存选项】-&gt; 点击【确定】即可添加</p>
<blockquote>
<p>开启该功能后就可以在【文件】菜单栏下找到【高级保存选项】了，将文件打开并进入编辑状态就可以打开该选项，就可以看到该文件的编码了。</p>
<p>通常在新建项目时，Visual Studio自动创建的文件都是UTF-8编码的，而自己新建的文件都是GBK编码的。</p>
</blockquote>
</li>
<li>
<p>接下来是强制将文件按照UTF-8进行保存</p>
<p>在这一步我们需要去下载一个插件，叫做 “Force UTF-8 (With BOM) 2022” 或者 “Force UTF-8 (No BOM) 2022”，这两者都可以，区别在于第一个会在文件前面添加签名标识文件的编码。</p>
<p>安装好并重启软件之后它就开始生效了。我们新创建一个文件，这时去查看它的编码应该仍然是GBK编码，我们点击一下保存，然后将文件叉掉再重新打开就可以看到它已经变成UTF-8编码了</p>
</li>
</ul>
<h4 id="2）更改MSVC的编码">2）更改MSVC的编码</h4>
<p>这一步完成之后，使用MSVC的过程就和使用GCC的过程（在编码上）基本一致了，其具体操作如下：</p>
<p>打开【项目属性】-&gt;【配置属性】-&gt;【C/C++】-&gt;【命令行】-&gt; 在【其他选项】中输入<code>/utf-8</code> -&gt;【确定】/【应用】即可</p>
<h4 id="3）测试">3）测试</h4>
<p>测试结果如下：</p>
<p><img src="/images/Windows%E7%8E%AF%E5%A2%83%E7%A8%8B%E5%BA%8F%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/05.png" alt="05"></p>
<p>可以看到，其输出结果和GCC过程相同了。</p>
<h2 id="二、-分析、方法及测试">二、 分析、方法及测试</h2>
<h3 id="1-分析">1. 分析</h3>
<h4 id="1）乱码的决定性环节">1）乱码的决定性环节</h4>
<p>我们需要分析的是，在文件、编译器、终端这三者之间，哪些的编码可以一致。</p>
<ul>
<li>
<p>首先是三者都相同，也就是默认状态下的MSVC的过程，虽然源文件可以是其他编码，但它最后会被MSVC转换成GBK编码</p>
</li>
<li>
<p>其次是二者相同的情况</p>
<ul>
<li>如果文件和编译器相同，那么可执行程序中的字符及字符串按照源文件编码保存，当终端编码与前二者不同时，将会产生乱码</li>
<li>如果编译器和终端相同，那么源文件的字符及字符串被解释为另一种编码，但二进制内容还是不变。然后按照被解释的编码进行输出，结果显然是乱码。</li>
<li>如果文件和终端相同（假设都为GBK），那么可执行程序中的字符在源文件中是GBK，而经过了编译器的转换，现在是UTF-8编码，但是虽然二者的解释不同，但是它们的内容还是一样的，所以当使用GBK编码的终端执行程序时，可执行程序中的UTF-8编码又被解释回了GBK编码，于是程序能够正常输出并且正常输入。</li>
</ul>
<p><strong>综上所述，实际上最终是否有乱码并不受编译器编码的影响，而只取决于源文件与终端二者的编码是否一致。</strong></p>
</li>
<li>
<p>最后是三者都不同的情况，根据我们刚才的结论，很明显这个会出现乱码</p>
</li>
</ul>
<h4 id="2）确定方向">2）确定方向</h4>
<p>根据上面所得出的结论，我们要做的就是让源文件编码和终端编码相同，而我们的目标是编写UTF-8程序并在所有环境的终端上都能正常运行。</p>
<p>所以很显然，我们的源文件应该是UTF-8编码的，而终端则可以是任何编码的。显然在这种情况下如果我们什么都不做，那么最终结果一定会出现乱码。</p>
<p>为了解决这个矛盾，我能想到的唯一（同时不麻烦用户）的办法就是<strong>在程序中插入代码改变运行环境</strong>。</p>
<h4 id="3）终端输入输出编码不统一">3）终端输入输出编码不统一</h4>
<p>根据上面的改进方向看上去很容易可以完成这样的修改，网上也有很多这样的方法，比如<code>chcp 65001</code>之类的方法。但使用<code>chcp</code>来修改终端代码页的方法经测试只能修改其输出编码，但是输入编码仍然是GBK，然后最后通过终端输出时又成了UTF-8编码，从而导致输入的回显乱码。</p>
<p>这也导致Windows终端编码的问题异常的难以解决。</p>
<h3 id="2-测试准备">2. 测试准备</h3>
<h4 id="1）测试代码">1）测试代码</h4>
<p>基本上还是上面的代码，不过经过了细微的修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的输入是：%s\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符数：%d\n&quot;</span>, <span class="built_in">strlen</span>(name));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是添加了一条语句计算输入字符串的长度，这条语句的本意是为了判断程序是否成功读取了内容，而不是真的为了计算输入的字符数量，毕竟汉字也不是单个字节。加上这一条的原因是在后面的测试中，有时会无法读取，为了判断是否刚好是空白乱码，所以添加了这样一句。</p>
<h4 id="2）乱码类型及原因">2）乱码类型及原因</h4>
<p>如下表所示：</p>
<table>
<thead>
<tr>
<th>乱码类型</th>
<th>示例</th>
<th>产生原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>古文码</td>
<td>鐢辨湀瑕佸ソ濂藉涔犲ぉ澶╁悜涓?</td>
<td>以GBK的方式读取UTF-8编码的中文</td>
</tr>
<tr>
<td>口字码</td>
<td>����Ҫ�¨²�ѧϰ������</td>
<td>以UTF-8的方式读取GBK编码的中文</td>
</tr>
<tr>
<td>符号码</td>
<td>ç”±æœˆè¦�å¥½å¥½å­¦ä¹ å¤©å¤©å�‘ä¸Š</td>
<td>以ISO8859-1方式读取UTF-8编码的中文</td>
</tr>
<tr>
<td>拼音码</td>
<td>ÓÉÔÂÒªºÃºÃÑ§Ï°ÌìÌìÏòÉÏ</td>
<td>以ISO8859-1方式读取GBK编码的中文</td>
</tr>
<tr>
<td>问句码</td>
<td>由月要好好学习天天向??</td>
<td>以GBK方式读取UTF-8编码的中文，<br />然后又用UTF-8的格式再次读取</td>
</tr>
<tr>
<td>锟拷码</td>
<td>锟斤拷锟斤拷要锟矫猴拷学习锟斤拷锟斤拷锟斤拷</td>
<td>以UTF-8方式读取GBK编码的中文，然后又用GBK的格式再次读取</td>
</tr>
</tbody>
</table>
<h3 id="2-5-测试前问题【严重】">2.5. 测试前问题【严重】</h3>
<p>我们的改进目标是在源文件中插入代码然后让程序本身在开始运行的时候自发改变运行环境，从而适应不同编码环境的终端，而其自发改变运行环境的最终目标当然是和源文件编码相同即UTF-8编码。</p>
<p>于是我在一个完全UTF-8编码的环境下进行了测试（我搭建了一台Windows虚拟机并在区域设置里调成了Beta版）。在其他环境下，即使通过调整使输出正常了，但输入却老是会出现乱码问题，这主要是源于前面所提到的一些方法只能改变终端的输出编码而导致终端输入输出编码的不同以致于乱码。</p>
<p>我想至少先在完全UTF-8编码的环境下进行测试，如果能正常输入输出，至少证明我们的方向是对的。但非常令人难以接受的是，即使在这样的环境下，程序仍然出错了。这一次不再是乱码错误，而是根本无法接收输入（表面上是这样），并且不论是MinGW还是MSVC编译的程序，效果都一样。</p>
<p>在调试之后，发现了问题所在，在完全UTF-8编码的机器上运行该程序，中文能够正常输出，但是输入的中文却无法正常读取，在调试过程中我发现所有的中文字符都被读取为了空字符（注意并不只有开头是空字符，是整个中文字符都被识别为了空字符，它们只在空字符数量上有区别），即使我将<code>scanf</code>函数改为了<code>fgets</code>函数，效果也是一样，<code>name</code>数组中被覆盖了的字节都是空字符（偶尔会有换行符），从而导致了读取的内容无法正常输入或者说是读取出错。</p>
<p>虽然找到了表面问题所在，但我对解决这个问题的方法却完全没有头绪。当我去问AI的时候，它告诉我可能是因为Windows的运行时库的影响，但没有任何具体的措施去解决。</p>
<p>综上原因，导致我无法确认后续所提出的方法是否达到了正确的效果。所以后续测试中如果出现输入乱码问题，我会对其进行分析；但如果出现输出读取问题，我就无法解释了。</p>
<h3 id="3-方法及测试">3. 方法及测试</h3>
<div class="tabs" id="methods"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#methods-1">chcp法</button></li><li class="tab"><button type="button" data-href="#methods-2">Win32 API法</button></li><li class="tab"><button type="button" data-href="#methods-3">setlocale法</button></li><li class="tab"><button type="button" data-href="#methods-4">添加字符转换层功能</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="methods-1"><ul>
<li>
<p>说明</p>
<p>先说明，此处的chcp法和我在前言部分提到的chcp法不同，那种方法是用户执行chcp改变终端环境，很明显违背了用户的需求，而且经过实测那一种方法实际上仍然有问题，如我在执行该命令后，再运行程序仍然输出乱码。</p>
</li>
<li>
<p>此处的chcp法是在程序内添加<code>system</code>函数来执行该指令，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;chcp 65001&quot;</span>);</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的输入是：%s\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符数：%d\n&quot;</span>, <span class="built_in">strlen</span>(name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要改动是添加了头文件<code>&lt;stdlib.h&gt;</code>以及一条<code>system</code>函数调用。</p>
</li>
<li>
<p>其运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Active code page: 65001</span><br><span class="line">你好</span><br><span class="line">你的输入是：��</span><br><span class="line">输入字符数：2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>分析</p>
<p>根据结果可以看出，其输出正常，但输入出现乱码。输入乱码则首先说明一点，就是终端的输入输出编码不一致，具体的原因根据前面的乱码类型表可以知道是以UTF-8的方式读取了GBK编码的中文。</p>
<p>输出正常说明输出编码是UTF-8编码，不难猜出输入编码应该还是GBK编码。实际也确实如此，我们输入的中文被终端转换为GBK编码然后原封不动保存到程序，最后程序交给终端这些数据之后，终端又以UTF-8编码输出该字符数据，从而导致以UTF-8的方式读取GBK编码的中文。</p>
</li>
<li>
<p>解决方法</p>
<p>暂时并没有该问题的（并且满足用户需求的）解决方案，同时也并不建议大家使用这个方法。首先就是因为输入编码与输出不一致的原因；其次如果你只是开发Windows程序的话倒是没什么大问题，但是如果你同时希望程序能够在Linux上编译运行成功，就不能这样做，因为Linux上没有chcp命令，当然也可以在代码中添加条件判断来做兼容，但这样就又会变得麻烦了一点。</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="methods-2"><ul>
<li>
<p>说明</p>
<p>该方法是使用<code>&lt;Windows.h&gt;</code>头文件中的函数来改变终端的环境</p>
</li>
<li>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOMINMAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SetConsoleCP(CP_UTF8);</span><br><span class="line">    SetConsoleOutputCP(CP_UTF8);</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的输入是：%s\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符数：%d\n&quot;</span>, <span class="built_in">strlen</span>(name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加了两个宏、一个头文件以及两条语句。</p>
</li>
<li>
<p>运行结果</p>
<p>此处运行结果非常奇怪，所有的输入最后都返回同样的乱码，有些甚至不算乱码，也就是一般的字符，但无一例外每次都返回相同的字符，在每一次重新启动终端后，返回的字符会发生变化，甚至有一次还复现了在本部分2.5节所提到的运行结果，或许二者有一定的关联。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">你好</span><br><span class="line">你的输入是：PP</span><br><span class="line">输入字符数：2</span><br><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">乱码测试</span><br><span class="line">你的输入是：PPPP</span><br><span class="line">输入字符数：4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">你好</span><br><span class="line">你的输入是：@@</span><br><span class="line">输入字符数：2</span><br><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">乱码测试</span><br><span class="line">你的输入是：@@@@</span><br><span class="line">输入字符数：4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">你好</span><br><span class="line">你的输入是：��</span><br><span class="line">输入字符数：2</span><br><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">乱码测试</span><br><span class="line">你的输入是：����</span><br><span class="line">输入字符数：4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">你好</span><br><span class="line">你的输入是：</span><br><span class="line">输入字符数：0</span><br><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">乱码测试</span><br><span class="line">你的输入是：</span><br><span class="line">输入字符数：0</span><br></pre></td></tr></table></figure>
<p>大致就是这4种结果，其中最后一种出现的比较少。通常在同一个终端里，一直运行该程序，其输出的字符都是同一种字符，如果重启了终端，则可能会变成另一种输出类型。另外如果开启两个终端交叉执行该程序，在同一个终端里，最后输出的结果也可能发生变化，但无一例外，每个单次输出的结果都是同一个字符。</p>
</li>
<li>
<p>解决方法</p>
<p>无法分析该结果</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="methods-3"><ul>
<li>
<p>说明</p>
<p>该方法使用标准库中的<code>setlocale</code>函数</p>
</li>
<li>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setlocale(LC_ALL, <span class="string">&quot;.utf-8&quot;</span>);</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的输入是：%s\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符数：%d\n&quot;</span>, <span class="built_in">strlen</span>(name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加了一个头文件及一条语句。</p>
</li>
<li>
<p>输出</p>
<p>我使用该方法得到的程序也有些问题，首先如果使用MinGW生成的程序，那么<code>setlocale</code>不生效，即输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">你好</span><br><span class="line">浣犵殑杈撳叆鏄細你好</span><br><span class="line">杈撳叆瀛楃鏁帮細4</span><br></pre></td></tr></table></figure>
<p>而如果使用Visual Studio生成程序，则其得到的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你好</span><br><span class="line">你的输入是：输入字符数：4</span><br></pre></td></tr></table></figure>
<p>真的是让人匪夷所思，它看上去成功读取了内容，因为最后显示长度为 4，但包含在源代码里的格式它都给我改了，它读取到的内容本身没有输出也就算了，我<code>printf</code>里的<code>\n</code>也没有输出，难道说读取内容的时候还把内存里的数据给改了？我尝试增加了<code>name</code>数组的大小也使用了Windows的<code>scanf_s</code>函数，但结果仍然没有任何改变。</p>
</li>
<li>
<p>解决方法</p>
<p>问题无法分析，解决方法无</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="methods-4"><p>该方法与前面三种方法对比，目前算是最靠谱的一种方法，具体的措施就是在程序和用户界面之间添加一层字符转换功能，这样同时也就不用改变用户终端环境，虽然和我们最开始决定的方向有所区别，但确确实实能解决问题，而且事实也证明改变用户终端环境的方法会出现很多问题。</p>
<p>而且第一中方法所得到的输入的字符还会出现一个问题（2、3种方法由于无法分析其输入错误的原因所以不做讨论）：在我们的程序只需要输出，并不会对输入进行回显但是却需要处理用户的中文输入的时候，我们将无法处理，因为我们在程序中将按照uft-8的编码（如果是宽字符，则一般是Unicode编码）进行处理，然而此时我们所获取到的用户输入确实GBK的编码，很显然在处理过程中会出现错误。而这种方法也同时解决了这样的问题。</p>
<p>它的具体过程如下所示：</p>
<p><img src="/images/Windows%E7%8E%AF%E5%A2%83%E7%A8%8B%E5%BA%8F%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/06.jpg" alt="06"></p>
<p>还是简单做了个测试，过程如下：</p>
<ul>
<li>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;convert.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 输出字符串定义与转换</span></span><br><span class="line">    <span class="type">char</span> firstOut_utf8[] = <span class="string">&quot;你输入的是：&quot;</span>;      <span class="comment">// 定义输出字符串（与源文件编码相同，即utf8）</span></span><br><span class="line">    <span class="type">char</span> secondOut_utf8[] = <span class="string">&quot;输入字符数：&quot;</span>;     <span class="comment">//</span></span><br><span class="line">    <span class="type">char</span> firstOut_gbk[<span class="number">20</span>];                     <span class="comment">// 用于保存编码转换后的输出字符串</span></span><br><span class="line">    <span class="type">char</span> secondOut_gbk[<span class="number">20</span>];                    <span class="comment">//</span></span><br><span class="line">    utf8ToGbk(firstOut_utf8, <span class="built_in">strlen</span>(firstOut_utf8), firstOut_gbk, <span class="number">20</span>);</span><br><span class="line">    utf8ToGbk(secondOut_utf8, <span class="built_in">strlen</span>(secondOut_utf8), secondOut_gbk, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入字符串定义与转换</span></span><br><span class="line">    <span class="type">char</span> name_gbk[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name_utf8[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name_unicode[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name_gbk2[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name_gbk);</span><br><span class="line">    gbkToUtf8(name_gbk, <span class="built_in">strlen</span>(name_gbk), name_utf8, <span class="number">20</span>);</span><br><span class="line">    multibyteToUnicode(name_utf8, <span class="built_in">strlen</span>(name_utf8), CP_UTF8, name_unicode, <span class="number">20</span>);</span><br><span class="line">    unicodeToMultibyte(name_unicode, <span class="built_in">strlen</span>(name_unicode), name_gbk2, <span class="number">20</span>, CP_ACP);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s%s\n&quot;</span>, firstOut_gbk, name_gbk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s%d\n&quot;</span>, secondOut_gbk, <span class="built_in">strlen</span>(name_gbk2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在头文件<code>convert.h</code>就是几个字符编码转换函数，主要有<code>utf8ToGbk</code>、<code>gbkToUtf8</code>（提供 UTF-8 和 GBK 之间的转换），以及<code>multibyteToUnicode</code>、<code>unicodeToMultibyte</code>（提供多字节编码（GBK、UTF-8）与 Unicode 编码之间的转换）。</p>
<p>在程序中可以看到，在输出字符串部分，我首先是定义了需要直接输出的字符串，然后用转换函数将其从UTF-8转换成了GBK；在输入字符串部分，首先是将获取到的gbk输入转换成<code>utf8</code>，再转换成<code>Unicode</code>，最后再转换回GBK（看上去是做的无用功，实际上确实也是，在这里主要是更突出一下这个转换函数确实是有作用的）。最后将都转换成GBK编码的字符串输出。</p>
</li>
<li>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe     </span><br><span class="line">你好</span><br><span class="line">你输入的是：你好</span><br><span class="line">输入字符数：4</span><br><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">乱码测试</span><br><span class="line">你输入的是：乱码测试</span><br><span class="line">输入字符数：8</span><br></pre></td></tr></table></figure>
<p>非常成功</p>
</li>
</ul>
<p>需要说明的是，这里的测试代码仅仅只是用于测试，包括头文件中的几个函数实际上都是非常不成熟的，毕竟没有人在使用<code>printf</code>之前先将需要输出的内容定义好；另外，如果是一个成熟的功能，我认为它至少还应该能够自动识别当前用户字符编码环境，然后提供程序与用户界面之间字符编码的自动转换，这样不仅让用户好用，也让程序员好写。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="三、-结论">三、 结论</h2>
<p>以上的几种方法是我在网上搜集到的一些方法，它们都能够比较好的解决输出乱码的问题，但是输入回显的乱码问题却仍然得不到解决。</p>
<p>在前三种方法中我原本最看好的是第三种，因为它不依赖与系统，但实际测试中却不知为何MinGW编译出的程序<code>setlocale</code>不生效，以及即使使用Visual Studio生成的程序<code>setlocale</code>生效了，但它似乎带来了比乱码更麻烦的问题。</p>
<p>第四种方法是当前比较完美的一种解决方案，该方案是在一位B站up主的帮助下获得的启发，已将其B站主页链接在文末。</p>
<hr>
<p>以上内容主要参考了该文章：<a href="https://zhuanlan.zhihu.com/p/627531212">记录Windows下开发C/C++如何避免乱码</a></p>
<p>以及非常感谢B站up主<a href="https://space.bilibili.com/356450253?spm_id_from=333.999.0.0">喜欢运动衫的帅帅</a>的帮助</p>
]]></content>
      <categories>
        <category>Windows</category>
        <category>问题探索</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>系统</tag>
        <tag>问题</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 工程组织【待更新】</title>
    <url>//posts/b3598d05/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C/C++</category>
        <category>开发实践</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>工程组织</tag>
        <tag>Linux</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Nodejs安装与配置</title>
    <url>//posts/358aad2/</url>
    <content><![CDATA[<h2 id="一、安装">一、安装</h2>
<div class="tabs" id="install_nodejs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#install_nodejs-1">包管理器安装</button></li><li class="tab"><button type="button" data-href="#install_nodejs-2">二进制文件安装</button></li><li class="tab"><button type="button" data-href="#install_nodejs-3">源码编译安装</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="install_nodejs-1"><p>本篇不会特别指出任何使用包管理器安装 Nodejs 的方法，如果你对包管理器不了解或者说不知道自己的系统的包管理器如何使用，我强烈建议你移步我的另一篇文章：<a href="/posts/9f09e5f1/">Linux 环境一般软件安装方法</a>，该篇文章详细说明了使用包管理器安装软件的一般方法，以后也就不用每次安装软件时都上网搜索了！</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="install_nodejs-2"><ol>
<li>
<p><strong>选择二进制包</strong></p>
<p><a href="https://nodejs.org/en/download">Nodejs 官网</a>提供了一种二进制包，首先通过前面的链接前往其下载页面：</p>
<p><img src="/images/358aad2/01.png" alt="01"></p>
<p>根据你机器的架构选择对应的二进制包即可。ARM 架构的 CPU 通常是手机平板等设备使用，如果是 PC，则通常选择 x86 即可</p>
<blockquote>
<p><strong>注意</strong>：</p>
<p>既然你都来搜索安装教程了，那我推荐你安装 LTS 版本（即长期支持版本），该版本比较稳定。</p>
</blockquote>
</li>
<li>
<p><strong>下载二进制包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v18.17.1/node-v18.17.1-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<ol>
<li>此处的链接是通过复制下载按钮链接获取的，如果你想下载最新的二进制包请自行前往官网获取</li>
<li><code>wget</code>工具的使用方法请使用<code>wget --help</code>自行获取，本篇不涉及该工具的使用教程</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>解压</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf node-v18.17.1-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<ol>
<li>
<p><code>tar</code>工具的使用方法请使用<code>tar --help</code>自行获取，本篇不涉及该工具的使用教程</p>
</li>
<li>
<p>解压会得到一个解压包，我解压所得到的名字是<code>node-v18.17.1-linux-x64</code>，由于你可能下载的版本和我不同，如果你是一个小白，建议你先将这个解压包按照下面的方法重命名，然后再跟着后面的教程走：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> node-v18.17.1-linux-x64 nodejs</span><br></pre></td></tr></table></figure>
<p>该解压包被重命名为<code>nodejs</code>，后续也以该名字为准</p>
</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>将其移动到<code>/opt</code>目录下</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> nodejs /opt/</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>添加环境变量</strong></p>
<p>不出意外的话，此时<code>node</code>、<code>npm</code>等可执行程序应该在<code>/opt/nodejs/bin/</code>目录下，我们需要将其添加到环境变量，才能方便地使用该应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=<span class="variable">$PATH</span>:/opt/nodejs/bin&quot;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
</li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="install_nodejs-3"><ol>
<li>
<p><strong>下载源码包</strong></p>
<p>首先，还是先前往 <a href="https://nodejs.org/en/download">Nodejs 官网</a>，这次我们选择 Source Code</p>
<p><img src="/images/358aad2/02.png" alt="02"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v18.17.1/node-v18.17.1.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<ol>
<li><code>wget</code>工具的使用方法请通过<code>wget --help</code>自行获取，本篇不提供<code>wget</code>的使用教程</li>
<li>此处的链接通过复制下载按钮链接得到，如果你想安装最新版请自行前往官网获取</li>
<li>建议下载 LTS 版本（即长期支持版本）</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>解压</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf node-v18.17.1.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<ol>
<li>
<p><code>tar</code>工具的使用方法请通过<code>tar --help</code>自行获取，本篇不提供<code>tar</code>的使用教程</p>
</li>
<li>
<p>我所解压出的包名是<code>node-v18.17.1</code>，由于你下载的版本可能和我的不同，为了方便后续教程的统一性，在此将解压包名修改为<code>nodejs</code>，后续也将以该名字为准：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> node-v18.17.1 nodejs</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>安装编译环境与依赖</strong></p>
<p>具体的编译环境与依赖可以前往官方的教程：<a href="https://github.com/nodejs/node/blob/main/BUILDING.md#building-nodejs-on-supported-platforms">node/BUILDING.md at main · nodejs/node · GitHub</a></p>
<p>主要关注两个地方，其一是某些工具或依赖的版本要求：</p>
<p><img src="/images/358aad2/03.png" alt="03"></p>
<p>其二是不同包管理器下的依赖安装方法：</p>
<p><img src="/images/358aad2/04.png" alt="04"></p>
<blockquote>
<p><strong>注意</strong>：</p>
<p>由于使用包管理器安装的依赖版本可能比较落后，或许无法满足其版本要求，所以可能需要采用其他方式进行安装</p>
</blockquote>
</li>
<li>
<p><strong>配置编译安装</strong></p>
<p>按顺序执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> nodejs				<span class="comment"># 移动到 nodejs 源代码目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /opt/nodejs			<span class="comment"># 在 /opt 下创建新目录 nodejs</span></span><br><span class="line">./configure --prefix=/opt/nodejs	<span class="comment"># 修改安装目录为 /opt/nodejs</span></span><br><span class="line">make					<span class="comment"># 编译</span></span><br><span class="line">make install				<span class="comment"># 安装</span></span><br></pre></td></tr></table></figure>
</li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<div class="note warning flat"><p><strong>关于通过 npm 包管理器安装工具的默认安装位置</strong>：</p>
<p>在曾经的 nodejs 版本中，通过 npm 安装工具时的默认安装位置在一个具有访问限制的目录下，虽然在该目录下安装可以直接将应用添加到系统默认查找目录从而方便使用，但在某些系统上该默认配置会导致一些权限错误以致于无法安装成功。</p>
<p>你可以通过下面的命令查看当前 npm 包管理器安装应用时的默认位置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure>
<p>如果你使用跟教程一样的版本号或者比教程更新的 nodejs 版本，并且按照上方【二进制文件安装】方法安装好 nodejs 之后，如果不出意外，则输出将会是<code>/opt/nodejs</code>。在我所使用过的 nodejs 版本中，npm 默认安装地址为二进制文件地址的版本最早大概是 18.16。</p>
<p>如果你通过上方的命令所得到的输出和本教程不同，比如为<code>/usr/local</code>等位置，我建议你将 npm 安装地址变更为<code>nodejs</code>所在位置，在本教程中即<code>/opt/nodejs</code>，此时安装的应用会将其可执行程序添加到<code>/opt/nodejs/bin</code>目录下，由于我们已经将此目录添加到了环境变量中，所以可以实现安装即用。</p>
</div>
<h2 id="二、配置">二、配置</h2>
<h3 id="npm-换源">npm 换源</h3>
<p>通过下面这条命令即可更新软件源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure>
<p>然后通过下面的命令查看是否更换成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>安装</tag>
        <tag>教程</tag>
        <tag>Nodejs</tag>
        <tag>npm换源</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Git安装与配置</title>
    <url>//posts/4446d03b/</url>
    <content><![CDATA[<h2 id="一、安装">一、安装</h2>
<div class="tabs" id="installgit"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#installgit-1">包管理器安装</button></li><li class="tab"><button type="button" data-href="#installgit-2">源码编译安装</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="installgit-1"><p>本篇不会特别指出任何使用包管理器安装 Git 的方法，如果你对包管理器不了解或者说不知道自己的系统的包管理器如何使用，我强烈建议你移步我的另一篇文章：<a href="/posts/9f09e5f1/">Linux 环境一般软件安装方法</a>，该篇文章详细说明了使用包管理器安装软件的一般方法，以后也就不用每次安装软件时都上网搜索了！</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="installgit-2"><ol>
<li>
<p><strong>下载源码</strong></p>
<p>你可以在 <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> 看到官网上所标注的最新的源代码版本，然后通过 <a href="https://mirrors.edge.kernel.org/pub/software/scm/git/">https://mirrors.edge.kernel.org/pub/software/scm/git/</a> 找到对应的版本下载即可。我所下载的文件是：<code>git-2.42.0.tar.gz</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.42.0.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<ol>
<li>可以在任何目录使用该命令，但如果是一些访问受限的系统目录下，需要登录<code>root</code>用户执行或在命令前加上<code>sudo</code>，后续命令同理</li>
<li>关于<code>wget</code>工具的用法可以通过<code>wget --help</code>进行查看，此处不详细介绍</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>解压压缩包</strong></p>
<p>我们下载下来的文件是一个<code>.tar.gz</code>的压缩包，需要用<code>tar</code>工具进行解压，如果没有该工具，则通过包管理器下载即可，包名称就叫<code>tar</code>。以下是解压命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf git-2.42.0.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<ol>
<li>
<p>关于<code>tar</code>工具的用法可以通过<code>tar --help</code>进行查看，此处不详细介绍</p>
</li>
<li>
<p>解压出来的目录名应该是<code>git-2.42.0</code>，考虑到本教程的通用性，我选择将其重命名为<code>git</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> git-2.42.0 git</span><br></pre></td></tr></table></figure>
<p>后续也请读者以<code>git</code>为准</p>
</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>依赖安装</strong></p>
<p>Git 的依赖库包含：<code>autotools</code>、<code>curl</code>、<code>zlib</code>、<code>openssl</code>、<code>expat</code>和<code>libiconv</code>。它们的包名分别是：<code>dh-autoreconf</code>、<code>curl-devel</code>、<code>expat-devel</code>、<code>gettext-devel</code>、<code>openssl-devel</code>、<code>perl-devel</code>、<code>zlib-devel</code>，请使用包管理器自行安装以上依赖库，本篇不提供包管理器的使用方法。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<p>使用 RHEL 和 RHEL 衍生版，如 CentOS 和 Scientific Linux 的用户可能需要开启 EPEL 库</p>
</blockquote>
</li>
<li>
<p><strong>编译安装</strong></p>
<p>依次执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> git				<span class="comment"># 进入之前解压出来的 git 源代码目录下</span></span><br><span class="line">make configure			<span class="comment"># 生成配置文件</span></span><br><span class="line"><span class="built_in">mkdir</span> /opt/git			<span class="comment"># 在 /opt 下创建一个新目录用于安装 git</span></span><br><span class="line">./configure --prefix=/opt/git	<span class="comment"># 修改配置中的安装位置到 /opt/git</span></span><br><span class="line">make				<span class="comment"># 编译</span></span><br><span class="line">make install			<span class="comment"># 安装</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>将 git 安装路径添加到环境变量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=<span class="variable">$PATH</span>:/opt/git/bin&quot;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>测试 git</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
</li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="二、配置">二、配置</h2>
<h3 id="1-配置-SSH-连接">1. 配置 SSH 连接</h3>
<div class="note info flat"><p>如果你使用 git 是为了能够往远程仓库推送内容，我推荐你配置一下 SSH 连接。而如果仅仅是为了克隆仓库到本地而不进行任何推送，则完全可以不配置 SSH 连接。</p>
<p>首先 ssh 和 git 是两个完全分离的工具，不要将它们混到一起。ssh 是 git 支持的一种传输方式，要启用这种传输，首先需要配置 ssh 密钥，从而将本地机器和远程 Github 服务器连接起来。</p>
</div>
<ul>
<li>
<p><strong>创建 SSH Key</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;&lt;your name&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<div class="note warning flat"><p>如果以前创建过这个密钥，则可以跳过这一步，通常在<code>~/.ssh/</code>目录下就可以找到以前创建的密钥文件。</p>
</div>
<div class="note info flat"><p>输入该命令之后会有一些输出，也会让你输入一些内容，比如创建密钥的位置，使用密钥的密码等等，通常保持默认即可，即一路回车。</p>
</div>
<p>创建成功后你可以看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your identification has been saved in /home/Username/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/Username/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:RwvBINgH8CEt2KniltmykeyDsOseUYcwMzehFeyT86s emailnum@email.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">| o+%OO+o.        |</span><br><span class="line">|..=+%*+ ..       |</span><br><span class="line">| ..+o+o.. .      |</span><br><span class="line">|o.  o=.  o .     |</span><br><span class="line">|o oolalala S o      |</span><br><span class="line">| +.+.. . .       |</span><br><span class="line">|. .o    .        |</span><br><span class="line">|  . .  .         |</span><br><span class="line">|   . E.          |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>复制公钥</strong></p>
<p>如果按照默认配置，则你的公钥文件<code>id_rsa.pub</code>应该放在<code>~/.ssh/</code>目录下，使用任何编辑器如 vim、gedit 打开该文件都可以，然后复制其中内容</p>
</li>
<li>
<p><strong>配置 Github SSH 密钥</strong></p>
<p>进入自己的 Github 主页，依次点击【Setting】-&gt;【SSH and GPG Keys】-&gt;【New SSH Key】按钮，Title 任意内容皆可，通常我比较喜欢和自己在创建 ssh 密钥时填写的名字一样。</p>
<p>然后将刚刚复制的密钥内容粘贴到下方文本框中，保存即可。</p>
</li>
<li>
<p><strong>测试 ssh 连接</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>第一次使用该密钥连接时会询问是否继续连接，输入<code>yes</code>回车确认即可，最后如果看到如下输出则说明配置成功了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hi You! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-其他配置">2. 其他配置</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;&lt;你的用户名&gt;&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;&lt;你的邮箱&gt;&quot;</span></span><br><span class="line">git config --global core.quotepath <span class="literal">false</span>		<span class="comment"># 解决中文路径显示乱码的问题</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
        <tag>安装</tag>
        <tag>配置</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境一般软件安装方法</title>
    <url>//posts/9f09e5f1/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>在刚开始学习使用 Linux 系统的时候，估计大家都在网上搜索过类似于如何在 Linux 上安装某某软件之类的问题，而且通常需要指明自己所使用的 Linux 发行版才能得到一个实际可行的解决方法。而且当你想要安装另一个不同的软件的时候，你又会像之前一样重新搜索一遍，你是否会发现实际上它们的安装方法都非常类似。</p>
<p>实际上，在 Linux 上安装某个软件，大概就是三种方法，最快速方便的方法就是使用<strong>包管理器</strong>进行安装；第二种是下载软件厂商已经为你编译好的<strong>二进制文件</strong>到系统进行安装；第三种是最耗时间也是出错率比较高的一种安装方法，即下载软件<strong>源代码</strong>，自行编译安装。</p>
<p>使用包管理器进行安装最为方便，但缺点其实也是最多的。对于初学者来说，由于本身对于包管理器没有一个清晰的认识，所以当你到另一个使用不同的包管理器的 Linux 系统上时就可能会无从下手，这也是为什么当你搜索一个软件安装教程的时候通常需要指定实际 Linux 的发行版名称才能得到一个比较可行的教程。另外，实际上包管理器就相当于你手机的应用商店，它的所有软件资源实际上是统一放在一个服务器中供包管理器使用的，由于这个服务器中的软件往往并不是和该软件官网发布的版本同步更新的，所以这也就导致你通过包管理器进行安装的软件要比该软件官网当前版本落后几个版本。</p>
<p>而使用二进制文件或者是使用源代码编译的方式进行安装，则不会有上述两个缺点，但相反要对软件的工作方式以及编译方法比较了解。</p>
<div class="note info flat"><p>本篇将着重介绍包管理器以及使用包管理器的软件安装方法，而使用二进制文件以及源代码编译的安装方式则简单介绍一下，特别是源代码编译的安装方式，由于各种软件编写方式不同，所以它们通过源代码编译的安装方式多多少少也有一点区别，对于某些软件我将会单独写一篇文章来介绍如何通过二进制文件或者源代码编译的方式进行安装，本篇中主要介绍通过包管理器安装软件的通用方法。</p>
</div>
<h2 id="一、包管理器安装">一、包管理器安装</h2>
<p>包管理器一般有两部分，一个是包管理器本身，另一个是包管理器的前端。比如在 Ubuntu 中，包管理器就是 dpkg，而其前端通常是 apt。二者的区别大概就是：包管理器本身如 dpkg 只负责安装现有的安装包，而包管理器的前端通常是从远程服务器下载对应安装包到系统上，然后调用包管理器来对软件进行安装。我们通常都是使用前端在远程获取安装包，但有时当远程服务器没有这个软件的时候，此时如果该软件官网提供了对应包管理器的安装包，我们也可以直接下载这样的安装包，然后使用包管理器进行安装。</p>
<p>比较常见的包管理器及其前端以及它们的使用方法如下：</p>
<div class="tabs" id="package_managers"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#package_managers-1">DPKG</button></li><li class="tab"><button type="button" data-href="#package_managers-2">RPM</button></li><li class="tab"><button type="button" data-href="#package_managers-3">PACMAN</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="package_managers-1"><p>dpkg 是 Debian Linux 家族的基础包管理系统，它用于安装、删除、存储和提供<code>.deb</code>包的信息。</p>
<blockquote>
<p><strong>常用命令</strong>：</p>
<p>参考：<a href="https://www.linuxcool.com/dpkg">dpkg命令 – 管理软件安装包 – Linux命令大全(手册) (linuxcool.com)</a></p>
</blockquote>
<p><strong>前端管理器</strong>：APT</p>
<p>由于 APT 比较常用，所以此处仅介绍 APT。</p>
<p>这个是一个 dpkg 包管理系统的前端工具，它是一个非常受欢迎的、自由而强大的，有用的命令行包管理器系统。</p>
<p>Debian 及其衍生版，例如 Ubuntu 和 Linux Mint 的用户应该非常熟悉这个包管理工具。</p>
<blockquote>
<p><strong>常用命令</strong>：</p>
<p>参考：<a href="https://www.linuxcool.com/apt-get">apt-get命令 – 管理服务软件 – Linux命令大全(手册) (linuxcool.com)</a></p>
</blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="package_managers-2"><p>这个是红帽创建的 Linux 基本标准（LSB）打包格式和基础包管理系统。</p>
<blockquote>
<p><strong>常用命令</strong>：</p>
<p><a href="https://www.linuxcool.com/rpm">rpm命令 – RPM软件包管理器 – Linux命令大全(手册) (linuxcool.com)</a></p>
</blockquote>
<p><strong>前端管理器</strong>：YUM</p>
<p>这个是一个开源、流行的命令行包管理器，它是用户使用 RPM 的界面（之一）。你可以把它和 Debian Linux 系统中的 APT 进行对比，它和 APT 拥有相同的功能。</p>
<blockquote>
<p><strong>常用命令</strong>：</p>
<p><a href="https://www.linuxcool.com/yum">yum命令 – 基于RPM的软件包管理器 – Linux命令大全(手册) (linuxcool.com)</a></p>
</blockquote>
<p><strong>前端管理器</strong>：DNF</p>
<p>这个也是一个用于基于 RPM 的发行版的包管理器，Fedora 18 引入了它，它是下一代 YUM。</p>
<p>如果你用 Fedora 22 及更新版本，你肯定知道它是默认的包管理器。</p>
<blockquote>
<p><strong>常用命令</strong>：</p>
<p><a href="https://www.linuxcool.com/dnf">dnf命令 – 新一代的软件包管理器 – Linux命令大全(手册) (linuxcool.com)</a></p>
</blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="package_managers-3"><p>这个是一个流行的、强大而易用的包管理器，它用于 Arch Linux 和其他的一些小众发行版。它提供了一些其他包管理器提供的基本功能，包括安装、自动解决依赖关系、升级、卸载和降级软件。</p>
<blockquote>
<p><strong>常用命令</strong>：</p>
<p><a href="https://www.linuxcool.com/pacman">pacman命令 – 软件包管理器 – Linux命令大全(手册) (linuxcool.com)</a></p>
</blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<div class="note primary flat"><p><strong>关于依赖</strong></p>
<p>Linux 和 Windows 的一个不同的地方就在于：Windows 中所安装的软件包会将自己所用到的所有的例如第三方库之类的依赖和自己的软件主体一起打包到一个安装包中，这方便了开发人员也方便了使用用户，但是却可能造成一个问题，就是有可能你某个软件里使用到了的依赖另一个软件中也用到了，但是它们在系统中却占有两份空间。而 Linux 则采用与之不同的方案，就是当你安装一个软件的时候，需要先安装好该软件的所有依赖才能正常运行，而依赖可能也有依赖，依次类推。这样的方式使软件的空间占有率得以下降，但相反的在安装时需要注意的地方就多了。</p>
<p>当你使用包管理器安装软件的时候，大多数的包管理器都可以自动处理依赖关系，当你安装软件时，包管理器会自动为你安装该软件的所有能找到的依赖，所以通常不用过多担心。实际上，即使没有自动为你安装依赖，在安装时包管理器也会提醒你缺哪些依赖，你再像安装一般软件一样安装依赖就可以了。</p>
</div>
<h2 id="二、二进制文件安装">二、二进制文件安装</h2>
<p>使用二进制文件安装软件是一个不错的选择，既可以安装到最新（或较新）的软件，过程也比较简单和通用。一般的二进制软件安装过程如下：</p>
<ul>
<li>下载二进制软件，并将其解压，解压包通常放置在一个统一的目录方便管理（通常会选择在<code>/opt/</code>目录）</li>
<li>将解压包中的可执行程序添加软链到系统查找目录（如<code>/usr/local/bin/</code>、<code>/usr/bin/</code>等）</li>
<li>在任意目录测试该可执行程序是否可以正常执行</li>
</ul>
<h2 id="三、源代码编译安装">三、源代码编译安装</h2>
<p>该方法的灵活性就比较高了，但也有基本操作步骤：</p>
<ul>
<li>下载源代码</li>
<li>配置编译条件</li>
<li>编译、安装</li>
</ul>
<p>从源代码的下载方式，到编译条件的配置方式以及最后编译以及安装的方式都各不相同，就不在此多废话，具体的软件的源代码编译安装方法就去找对应的软件安装教程即可，但还是要提一句，在 Linux 上最常见的软件还是使用 C/C++ 编写的，并且它们的配置以及编译安装的方式也都差不多，通常保证你的系统里有 gcc、g++、make 这几个软件就可以完成编译了。</p>
<h2 id="推荐">推荐</h2>
<div class="note info flat"><p><strong>通过下方链接可以前往本博客已经提供的使用二进制文件方法或者源代码编译方法的安装教程：</strong></p>
<ul>
<li><a href="/posts/4446d03b/">Git</a></li>
<li><a href="/posts/358aad2/">nodejs</a></li>
</ul>
</div>
]]></content>
      <categories>
        <category>Linux</category>
        <category>基本使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>教程</tag>
        <tag>软件安装</tag>
      </tags>
  </entry>
</search>
