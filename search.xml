<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CLion入门</title>
    <url>//posts/872d1bb0/</url>
    <content><![CDATA[<h2 id="一、-CMake">一、 CMake</h2>
<p>在打开 CLion 后，我最疑惑的一点就是在我的项目源文件里的一个文件：<code>CMakeLists.txt</code>，我根本不知道这是干嘛用的。</p>
<p>先说结论，这是<code>cmake</code>的脚本文件，<code>cmake</code>是一个工具，它可以执行这样的一个文件。而要知道 CMake 是个什么东西，那就需要先回到全手动的代码编译过程中去。</p>
<h3 id="1-手敲命令编译程序">1. 手敲命令编译程序</h3>
<ul>
<li>首先我们准备好所有的源文件</li>
<li>然后通过<code>gcc\g++</code>命令来编译源文件成最终的可执行文件（其中的预编译、编译、汇编、链接等过程不进行详细考虑，这其中所有的过程暂时统一称为编译）</li>
</ul>
<p>就是这么简单的两步而已，看起来会觉得 IDE 根本没有用武之地，但是仔细想想第二个过程，如果我们的源文件很多，并且分散在不同的文件夹中，而且有时还需要链接第三方库，那么我们如果是在调试阶段，那每一次修改代码都需要写一长串的<code>gcc\g++</code>命令，所以针对这个问题，就有一种解决方案出来了，就是 makefile</p>
<h3 id="2-编写命令脚本编译程序">2. 编写命令脚本编译程序</h3>
<p>makefile是一种脚本文件，我们提前在这个文件里写好这个项目需要如何编译，包括一些复杂的命令之类的。然后我们在每一次修改代码之后直接使用<code>make</code>工具运行这个<code>makefile</code>脚本即可按照预先写好的过程进行编译，那么在调试阶段我们就可以省下很多用于写命令的时间。</p>
<p>有人会发现，好像到这里就可以结束了，我们只需要提前写好一份 makefile 就可以了，还有 IDE 什么事呢？</p>
<p>其实，makefile 有一个缺点，那就是不跨平台。我们的程序可能需要跑在多种系统，多种机器上，但 makefile 不跨平台，也就是说一个 makefile 文件只能编译出一个平台上可用的程序，要想做到生成多个平台的程序，那就需要写多个 makefile，这个工程量人力虽然也是可完成的，但是难免会觉得累，就像把一段只有一两个变量不同的重复代码写了很多遍一样。</p>
<p>解决的方法其实也就在上一段话中，我们可以通过函数来解决重复代码的问题，也就是抽象，而足够抽象的东西是具有高度的复用性的。而 CMake 也就是 makefile 等工具的抽象。</p>
<h3 id="3-通过构建工具生成适应平台的脚本">3. 通过构建工具生成适应平台的脚本</h3>
<p>使用 CMake 首先需要一个<code>CMakeLists.txt</code>文件，有了这个文件，我们就可以执行<code>cmake</code>命令（和使用<code>gcc\g++</code>命令类似），通过使用<code>cmake</code>命令，我们就可以得到一个根据<code>CMakeLists.txt</code>的内容生成的符合我们当前环境（需要先设置好工具链，在下一节会讲到）的 Makefile 文件（也可能是其他文件如 <code>build.ninja</code>，通过 CMake 的配置项决定）。</p>
<p>然后点击构建按钮，IDE 就会使用我们预先配置好的生成器（如 make）来执行这个 Makefile 文件，然后我们就能得到需要的可执行程序了。</p>
<p>点击运行按钮，IDE 就会运行这个可执行程序了。</p>
<h2 id="二、-CLion">二、 CLion</h2>
<h3 id="1-工具链">1. 工具链</h3>
<p>在上一节我们说到了 CMake 的工作原理，很显然，要使用 CMake，我们首先必须要有四样东西：</p>
<ol>
<li>CMake：这个软件一般在安装 IDE 的时候会自动安装，用于生成编译用的脚本</li>
<li>构建工具：如 make、ninja 等，即通过执行编译脚本构建可执行程序的工具，用于构建可执行程序。</li>
<li>编译器：如 gcc、g++ 等，是在构建工具执行编译脚本时所必需的一个工具，否则无法正常生成可执行程序</li>
<li>调试器：如 gdb 等，即代码还在调试阶段时 CMake 生成的脚本会保留调试信息，由于调试是一个程序基本上逃不过的过程，所以调试器也是必要的。</li>
</ol>
<p>这四种工具在 CLion 中合称“工具链”，如下图所示：</p>
<p><img src="/images/CLion%E5%85%A5%E9%97%A8/01.png" alt="01"></p>
<p>需要注意的是在工具链的配置中最主要的工具实际上是：编译器、调试器和 CMake 这三项，而生成工具实际上在配置工具链这一步并非主要，之所以需要配置，是要确保你是否有这样的一种工具。同时之所以通过 CMake 能够生成符合我们当前环境的脚本文件就是由于这个工具链，因为在配置工具链时我们要保证每一个工具都存在且能够正常运行。</p>
<h3 id="2-项目配置">2. 项目配置</h3>
<p>在配置好工具链后，我们就可以来配置 CMake 了，具体的配置项如下图所示：</p>
<p><img src="/images/CLion%E5%85%A5%E9%97%A8/02.png" alt="02"></p>
<p>其具体的配置项如下：</p>
<ul>
<li>
<p>名称：随便起，这只是一个配置文件的名称而已</p>
</li>
<li>
<p>构建类型：最主要的就是<code>Debug</code>和<code>Release</code>两种，其中<code>Debug</code>类型会在构建时保留调试信息，便于调试，而<code>Release</code>类型不会保留这类信息，同时其性能比<code>Debug</code>要好</p>
</li>
<li>
<p>工具链：即我们上一步配置好的工具链，可以配置多个工具链，然后在这里选择一个即可，默认工具链一般是第一个工具链，主要使用到的是 CMake 、编译器和调试器这三项</p>
</li>
<li>
<p>生成器：也就是在工具链中配置的构建工具，在这里如果选择默认那么就是在上一项所选择的工具链中的构建工具，也可以选择其他的生成器</p>
</li>
<li>
<p>CMake 选项：也就是在我们写好<code>CMakeLists.txt</code>文件之后执行<code>cmake</code>命令时后面所跟的选项，最主要的就是<code>-G</code>选项，用于选择生成的脚本的类型，一般在选择好生成器之后会自动填在下面</p>
</li>
<li>
<p>构建目录：生成好的脚本文件就放在这个目录下面</p>
</li>
<li>
<p>构建选项：这是当我们已经生成了脚本文件之后，构建时使用<code>cmake</code>命令时的选项，即在这种配置下，点击构建按钮时 IDE 执行的命令应该像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake --build <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span> --target <span class="variable">$&#123;PROJECT_NAME&#125;</span> -j 9</span><br></pre></td></tr></table></figure>
<p>其中第一个选项是我们上一项配置中所设置好的构建目录，<code>PROJECT_BINARY_DIR</code>是在<code>CMakeLists.txt</code>文件中定义好的，第二个选项是要生成的可执行文件的名称，<code>PROJECT_NAME</code>也是我们在<code>CMakeLists.txt</code>中定义好的，然后最后的选项就是我们在构建选项这一框中填写的内容。</p>
<p>这个命令首先在<code>PROJECT_BINARY_DIR</code>这个目录下生成与我们选择的生成器所对应的脚本文件，如 make 对应的就是 makefile，Ninja 对应的就是 build.ninja。然后它会调用我们选择的生成器来执行刚刚生成的脚本文件，最终生成我们需要的可执行文件。</p>
</li>
</ul>
<p>由于 CMake 生成脚本文件的依据就是<code>CMakeLists.txt</code>文件和我们选择的生成器，所以基本上决定一个项目如何编译就是靠的<code>CMakeLists.txt</code>这个文件，而写这个文件就需要去学习 CMake 的编写方法，这在本文中不会进行介绍。</p>
<h2 id="三、-项目结构">三、 项目结构</h2>
<p>在新建一个项目后，我们会看到文件夹里多了一些文件，理解这些文件对我们理解 CLion 的工作原理是有帮助的。</p>
<ul>
<li><code>.idea</code>：这个文件夹不算重要，它是用于标识其父文件夹是一个 CLion 项目用的</li>
<li><code>cmake-build-debug</code>：一般新建项目之后都有这个文件夹，这是因为新建项目都会自动生成一个 CMake 配置文件，这个配置文件选择的构建类型都是<code>Debug</code>类型，而且其构建目录的名称也都是<code>cmake-build-$&#123;构建类型&#125;</code>的格式，所以会有这样一个文件夹。如果我们新建一个 CMake 配置文件并且启用，那么我们只要用<code>cmake</code>运行一下<code>CMakeLists.txt</code>文件就可以发现又多了一个与其类似的文件夹。<code>cmake</code>命令生成的脚本文件以及最后的可执行文件都在这个文件夹下，其中另外一些其他的文件及文件夹并非特别重要。</li>
<li><code>CMakeLists.txt</code>：这个文件即<code>cmake</code>执行的文件，<code>cmake</code>会根据其内容生成对应的脚本文件</li>
<li>其他文件：主要就是我们的项目的主体了，一般新建项目会自动创建一个<code>main.c</code>或者<code>main.cpp</code></li>
</ul>
<h2 id="四、-总结">四、 总结</h2>
<p>在本文中，我们主要讲解了 CMake 的工作原理以及 CLion 如何利用 CMake 进行工作，以及 CLion 中工具链的概念。同时具体解释了 CLion 中最重要的两个配置项的配置，即 工具链 和 CMake。</p>
<p>而所有另外的配置都比较简单也都不是 CLion 中需要理解的重要设置，如更换主题，设置代码格式等等。</p>
<p>通过本文，我们应该了解了 CMake 在 CLion 的一个重要地位，我们只需要写好一个<code>CMakeLists.txt</code>文件，就可以在不同的平台，方便快捷地构建我们需要的项目。所以实际上使用 CLion 的本质也就是使用 CMake，当然本文只是一个入门，并不讨论 CMake 应该怎么写，学习 CMake 的编写可以去看看官方的文档，也可以去找一找其他人的相应的教程。</p>
<hr>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>CLion</tag>
        <tag>CMake</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu基本配置</title>
    <url>//posts/c7af8c65/</url>
    <content><![CDATA[<h2 id="一、-准备">一、 准备</h2>
<h3 id="1-安装环境">1. 安装环境</h3>
<p>系统：Ubuntu-22.04.1</p>
<p>主机：Lenovo XiaoXinAir-14ARE 2020</p>
<p>内存：16G</p>
<p>处理器：AMD® Ryzen 5 4600u with radeon graphics × 12</p>
<p>显卡：AMD® Renoir</p>
<p>硬盘：512 GB</p>
<h3 id="2-写在前面">2. 写在前面</h3>
<p>本文仅作为物理机安装Ubuntu系统的参考，虚拟机大部分操作类似，但如果想安装虚拟机，请寻找更合适的文章。</p>
<p>另外，本文很大程度上是为了帮助我自己重装系统，所以很多地方的特殊性会比较强，可能不适合其他的电脑，希望大家自己判断。</p>
<p>最后，本文参考了很多的文章，但不打算列出，因为我基本上只从那些文章中抽取出了一小部分我需要的，然后组合成了这一篇文章（主要是因为参考的文章实在是太多了 -_-，然后在我安装的时候也没有记录那些文章，只记录了需要的操作，然后这篇文章又是后来写的，所以基本上很难去找了）</p>
<h2 id="二、-安装Ubuntu">二、 安装Ubuntu</h2>
<h3 id="1-下载ISO文件">1. 下载ISO文件</h3>
<p>首先我们选择一个镜像源，我选择的是北京外国语大学的镜像：<a href="https://mirrors.bfsu.edu.cn/">https://mirrors.bfsu.edu.cn/</a></p>
<p>然后找到我们要下载的文件，是<code>/ubuntu-releases/22.04.1/</code>这个目录下的<code>ubuntu-22.04.1-desktop-amd64.iso</code>，下载即可</p>
<h3 id="2-制作启动U盘">2. 制作启动U盘</h3>
<p>首先我们需要一个制作启动U盘的软件，是软碟通，通过这个链接可以下载：<a href="https://cn.ultraiso.net/xiazai.html">https://cn.ultraiso.net/xiazai.html</a></p>
<p>具体的使用方法是：进入软件-&gt;打开下载的iso文件-&gt;点击“启动-写入硬盘映像”-&gt;选择用于制作启动盘的U盘-&gt;点击&quot;写入&quot;-&gt;等待完成即可</p>
<h3 id="3-启动BIOS设置U盘启动">3. 启动BIOS设置U盘启动</h3>
<p>各个电脑打开BIOS的操作可能不一样，总之这一步自己查询，进到BIOS里就行了。</p>
<p>然后设置BIOS启动即可，由于各个电脑的BIOS界面可能也不同，所以就不详细介绍了，记录一下我自己的操作：直接从<code>Boot Menu</code>中选择U盘启动即可。</p>
<h3 id="4-开始安装">4. 开始安装</h3>
<p>安装的其他步骤都很简单，唯一需要介绍的一步是：分区操作</p>
<p>首先我是想安装一个和Windows的双系统，先简单介绍一下需要分配的分区：</p>
<ul>
<li><code>\boot</code>：由于我只有一个物理硬盘，所以从硬盘里直接分出想要的空间大小即可（这一部分空间应该显示为未分配）。如果是多个物理硬盘，那么一定要从Windows系统盘所在的硬盘中分出一部分留给<code>\boot</code>分区，这个分区是放Ubuntu的启动程序分区，由于计算机在启动时只会在一个盘里查找启动程序，如果不在同一个硬盘存放启动程序，那么启动电脑时就只会启动Windows。<code>\boot</code>分区留个300M-500M就行了。（我直接在这个盘里分了200个G用作所有的空间）</li>
<li><code>swap</code>：还有一个比较重要的分区是<code>swap</code>分区，它相当于是内存的缓冲，如果有固态硬盘，一般也用固态硬盘来分，主要是为了更快的速度。这一块的大小根据内存的大小决定，一般内存为8G及以下的，留内存的双倍即可；如果内存大于等于16G，那留与内存相同的空间即可。我留16G即可。</li>
<li><code>\home</code>：该分区是放置用户文件的分区，主要根据自己的使用习惯分配即可。我一般不把安装的软件放在这个目录下，所以我留了30个G左右</li>
<li><code>\</code>：根分区里放置了所有的文件，包括刚刚分配的<code>\home</code>分区，但是由于我们将<code>\home</code>分区单独挂载了，所以为根目录分配的空间将不包括<code>\home</code>的空间，但是逻辑上还是有<code>\home</code>分区的。我把剩下的150G左右都留给了根目录</li>
</ul>
<p>然后简单来说一下分区的方法吧：</p>
<ul>
<li>首先，我们在需要分区的安装步骤处，选择最后一项：自己分区</li>
<li>如果是新配的电脑，还没安装任何系统的话，那么这个页面应该只列出了相应的设备，即硬盘。我们选择需要分配内存的硬盘，选择新建分区表即可，然后按照下面的步骤继续</li>
<li>我们可以看到分区表里那一个或多个后面显示“空闲”的空间，我们可以通过前面的空间大小知道它是我们之前分出来用来作哪个分区的。我们选择相应的空间，点击左下角的<code>+</code>号，然后就会进入分配空间大小及分区挂载的界面</li>
</ul>
<p>接下来，我们就来说一下各个分区的具体配置吧：</p>
<ul>
<li><code>swap</code>：大小根据之前说的方法来选择；分区选择逻辑分区；挂载点里没有<code>swap</code>挂载点，这个在挂载点上面的“用于”的下拉框中选择“交换空间”即可</li>
<li><code>\boot</code>：大小分配300-500M；分区选择逻辑分区；类型为<code>ext4</code>；挂载点里选择<code>\boot</code></li>
<li><code>\</code>：大小自行分配（我是150G）；分区选择逻辑分区；类型为<code>ext4</code>；挂载点里选择<code>\</code></li>
<li><code>\home</code>：大小自行分配（我是30G）；分区选择主分区；类型为<code>ext4</code>；挂载点里选择<code>\home</code></li>
</ul>
<p>最后，也是最重要的一步：</p>
<p>首先，我们可以看到安装程序已经自动为我们选择的分区分配了设备名，我们找到刚刚<code>\boot</code>分区的设备名，然后<strong>在“安装启动引导器的设备”中选择刚刚<code>\boot</code>分区的设备名即可</strong>。</p>
<p>点击“现在安装”，等待安装完成即可。</p>
<h2 id="三、-换源">三、 换源</h2>
<p>由于Ubuntu官方的源下载速度很慢，所以需要换源。</p>
<p>首先，我们选择一个镜像源，我选择的还是北京外国语大学的镜像源：<a href="https://mirrors.bfsu.edu.cn/help/ubuntu/">https://mirrors.bfsu.edu.cn/help/ubuntu/</a></p>
<p>打开这个页面就可以看到它提供的镜像源和替换方法，这里记录一下手动替换的操作：</p>
<ul>
<li>首先将原本的镜像源备份：<code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup</code></li>
<li>通过<code>sudo gedit /etc/apt/sources.list</code>打开并编辑镜像源文件</li>
<li>然后将该文件里原本的内容删除，然后将网页里的内容复制粘贴到该文件里，点击保存即可</li>
</ul>
<p>然后我们就可以进行更新操作了，执行下面两步操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>
<h2 id="四、-其他安装项（可选）">四、 其他安装项（可选）</h2>
<h3 id="1-fastgithub">1. fastgithub</h3>
<div class="tabs" id="fastgithub"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fastgithub-1">下载</button></li><li class="tab"><button type="button" data-href="#fastgithub-2">安装</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fastgithub-1"><p>下载地址：<a href="https://github.com/dotnetcore/FastGithub/releases/download/2.1.4/fastgithub_linux-x64.zip">https://github.com/dotnetcore/FastGithub/releases/download/2.1.4/fastgithub_linux-x64.zip</a></p>
<p>如果下载速度慢，我们可以使用下面的网站提供的加速服务：<a href="https://ghproxy.com/">https://ghproxy.com/</a></p>
<blockquote>
<p>上面提供的下载地址为2.1.4版本，由于版本可能更新，可以通过下面的网址查看最新版本：<a href="https://github.com/dotnetcore/FastGithub/releases">https://github.com/dotnetcore/FastGithub/releases</a> ，根据自己的系统和架构选择应该下载的软件包即可。</p>
</blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fastgithub-2"><ul>
<li>
<p>我们将下载下来的软件包解压，然后将其移动到<code>/opt</code>目录下，然后自己移动到<code>fastgithub</code>文件夹下</p>
</li>
<li>
<p>首次运行一下该程序，生成证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./fastgithub</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以看到证书已经生成了，我们先不管，先设置一下代理：打开网络设置，点击网络代理后面的设置按键，选择自动，然后在下面的框中输入：<a href="http://127.0.0.1:38457">http://127.0.0.1:38457</a> 即可</p>
</li>
<li>
<p>我们将刚刚生成的证书文件移动到<code>/usr/local/share/ca-certificates</code>文件夹下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> cacert/fastgithub.crt /usr/local/share/ca-certificates</span><br></pre></td></tr></table></figure>
<p>然后执行更新操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-ca-certificates</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>同时浏览器需要导入证书，具体操作步骤如下：打开浏览器-&gt;设置-&gt;隐私与安全-&gt;证书-&gt;查看证书-&gt;证书颁发机构，导入<code>cacert/fastgithub.crt</code>，勾选“信任由此证书颁发机构来标识网站“</p>
</li>
<li>
<p>然后添加一个 git 全局配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.sslverify <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后将程序添加软链用来快捷打开：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /opt/&lt;fastgithub软件包&gt;/fastgithub /usr/local/bin</span><br></pre></td></tr></table></figure>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="2-git">2. git</h3>
<div class="tabs" id="fastgithub"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fastgithub-1">安装</button></li><li class="tab"><button type="button" data-href="#fastgithub-2">添加SSH Key</button></li><li class="tab"><button type="button" data-href="#fastgithub-3">其他配置</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fastgithub-1"><p>执行下面的命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fastgithub-2"><ol>
<li>
<p>首先创建SSH密钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;&lt;你的用户名&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>接下来会有一些输出，主要是key的存放位置和密码设置，直接默认回车即可</p>
<p>最后看到类似如下的输出，就表示成功生成SSH key了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your identification has been saved in /home/Username/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/Username/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:RwvBINgH8CEt2KniltmykeyDsOseUYcwMzehFeyT86s emailnum@email.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">| o+%OO+o.        |</span><br><span class="line">|..=+%*+ ..       |</span><br><span class="line">| ..+o+o.. .      |</span><br><span class="line">|o.  o=.  o .     |</span><br><span class="line">|o oolalala S o      |</span><br><span class="line">| +.+.. . .       |</span><br><span class="line">|. .o    .        |</span><br><span class="line">|  . .  .         |</span><br><span class="line">|   . E.          |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>复制密钥</p>
<p>密钥内容放在用户文件夹下的<code>.ssh/id_rsa.pub</code>文件中，可以打开文本编辑器进行复制；</p>
<p>然后进入自己的github主页，依次点击：Settings-&gt;SSH and GPG keys-&gt;New SSH key按钮，Title随便输，然后在下面的文本框粘贴刚复制的内容，最后点击保存即可</p>
</li>
<li>
<p>测试SSH连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>输出会首先询问是否确认连接，输入yes回车确认即可，最后会看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hi You! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
</li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fastgithub-3"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;&lt;你的用户名&gt;&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;&lt;你的邮箱&gt;&quot;</span></span><br><span class="line">git config --global core.quotepath <span class="literal">false</span>		/* 解决中文路径显示乱码的问题 */</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="3-vscode">3. vscode</h3>
<div class="tabs" id="fastgithub"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fastgithub-1">下载</button></li><li class="tab"><button type="button" data-href="#fastgithub-2">安装</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fastgithub-1"><p>直接在官网下载<code>.deb</code>文件：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fastgithub-2"><p>通过下面的命令安装即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i &lt;packagename&gt;</span><br></pre></td></tr></table></figure>
<p>然后打开软件登陆同步配置即可</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="4-typora">4. typora</h3>
<div class="tabs" id="fastgithub"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fastgithub-1">下载</button></li><li class="tab"><button type="button" data-href="#fastgithub-2">安装</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fastgithub-1"><p>直接在官网下载<code>.deb</code>文件：<a href="https://typoraio.cn/#linux">https://typoraio.cn/#linux</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fastgithub-2"><p>通过下面的命令安装即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i &lt;packagename&gt;</span><br></pre></td></tr></table></figure>
<p>然后打开软件设置激活即可</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="5-gcc">5. gcc</h3>
<p>直接通过下面的命令即可安装 gcc：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc</span><br><span class="line">sudo apt install g++</span><br></pre></td></tr></table></figure>
<h3 id="6-node">6. node</h3>
<div class="tabs" id="fastgithub"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fastgithub-1">安装</button></li><li class="tab"><button type="button" data-href="#fastgithub-2">npm换源</button></li><li class="tab"><button type="button" data-href="#fastgithub-3">安装测试</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fastgithub-1"><p>我们通过二进制文件安装：</p>
<p>首先，我们去官网下载二进制文件：<a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a> ，选择对应的系统和架构选择下载即可，下载下来是一个压缩包，我们首先解压缩：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xf &lt;packagename&gt;</span><br></pre></td></tr></table></figure>
<p>然后将解压后的包移动到<code>/opt</code>目录下</p>
<p>首先运行一下程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./&lt;node_packagename&gt;/bin/node -v</span><br></pre></td></tr></table></figure>
<p>我们可以看到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v16.18.1</span><br></pre></td></tr></table></figure>
<p>接下来我们设置软链即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /opt/&lt;node_packagename&gt;/bin/npm /usr/local/bin/</span><br><span class="line"><span class="built_in">ln</span> -s /opt/&lt;node_packagename&gt;/bin/node /usr/local/bin/</span><br></pre></td></tr></table></figure>
<p>安装就完成了，测试一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>如果正常显示版本号就表明成功了</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fastgithub-2"><p>由于原淘宝域名即将停止解析，所以将镜像源地址更新为如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure>
<p>通过下面这条命令更新软件源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure>
<p>然后通过下面的方法来验证是否成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fastgithub-3"><p>首先我们查看一下npm的默认安装位置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般来说，18.16版本之后的 node 的默认安装位置应该都是在你解压出来的目录下，以前在一个系统目录下，会产生权限问题，现在则没有这个问题了，只不过我们在安装完后需要自行添加软链，否则无法直接使用命令。</p>
</blockquote>
<p>安装hexo测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>如果我的 node 文件夹在<code>/opt</code>目录下，则它会安装到<code>/opt/node/lib/node_modules/hexo-cli/bin/</code>下面，我们像下面这样添加软链即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /opt/node/lib/node_modules/hexo-cli/bin/hexo /usr/local/bin/</span><br></pre></td></tr></table></figure>
<p>需要注意的是，添加软链时地址一定是绝对地址，不要填成了相对地址。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="7-JetBrains">7. JetBrains</h3>
<div class="tabs" id="fastgithub"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fastgithub-1">下载</button></li><li class="tab"><button type="button" data-href="#fastgithub-2">安装</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fastgithub-1"><p>主要有两种下载安装方法，对于只需要 JB 中的某一个软件的用户来说，直接去相应软件的下载页面下载即可，这里不进行详述。</p>
<p>对于需要多个 JB 软件的用户来说，可以先下载一个 JetBrains ToolBox ，然后在这个软件里下载需要的软件，同时该软件还可以对项目进行管理，非常方便，接下来简单说一下下载方法。</p>
<p>首先直接前往软件的下载页面：<a href="https://www.jetbrains.com/zh-cn/toolbox-app/?_gl=1*1bx53n1*_ga*OTY4ODkxMTkxLjE2NzUwNzkwOTg.*_ga_9J976DJZ68*MTY3NTE2MjgxNy4yLjEuMTY3NTE2MjgzMy4wLjAuMA..&amp;_ga=2.17468218.2027988100.1675079099-968891191.1675079098">ToolBox App</a></p>
<p>然后直接下载页面推荐的文件格式即可（我是 Ubuntu，所以选择 .tar.gz 格式的文件），点击下载即可</p>
<p>在等待下载的这一段时间里，我们可以点击下载按钮下方的 <strong>系统要求</strong>，来查看在安装之前需要做的准备：</p>
<p><img src="/images/Ubuntu%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/01.png" alt="01"></p>
<p>可以看到，在 Linux 环境下，我们还需要下载一些软件包才能正常使用 ToolBox</p>
<p>我们打开终端，输入以下命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install libfuse2 libxi6 libxrender1 libxtst6 mesa-utils libfontconfig libgtk-3-bin</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fastgithub-2"><p>下载好 ToolBox 的安装包文件之后，输入下面的命令解压缩即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf &lt;package-name&gt;</span><br></pre></td></tr></table></figure>
<p>然后运行一下解压之后的文件夹里的可执行文件即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./jetbrains-toolbox</span><br></pre></td></tr></table></figure>
<p>如果能够看到下面的界面，就说明安装成功了：</p>
<p><img src="/images/Ubuntu%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/02.png" alt="02"></p>
<p>然后就可以在 ToolBox 里安装需要的软件了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="8-Chrome">8. Chrome</h3>
<p>首先移动到安装 Chrome 的目录，然后执行下面的命令下载最新的<code>.deb</code>软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure>
<p>然后执行下面的命令安装即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ./google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure>
<h2 id="五、-外观">五、 外观</h2>
<h3 id="1-缩放与字体大小">1. 缩放与字体大小</h3>
<p>和 Windows 的全局缩放相比，Ubuntu 的全局缩放基本上是用不了的，即使只是 125%，也看起来很模糊，所以对于小屏幕（如我的笔记本只有 14 英寸）来说，改变观感的方法只能从各个软件入手。以下设置完全以我的屏幕大小为参考：</p>
<p><strong>vscode</strong>：在设置文件中添加如下代码即可：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;window.zoomLevel&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;settingsSync.ignoredSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;-window.zoomLevel&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一项设置窗口的缩放等级，原始大小为 0（可根据实际需要进行缩放）</li>
<li>第二项设置将上一项设置加入默认同步设置项中（第一项设置默认不同步，如果再次安装需要重新设置）</li>
<li>更换大屏显示器后将上述两项注释掉即可</li>
</ul>
<p><strong>typora</strong>：直接在 <strong>偏好设置-外观</strong> 设置中调整自己需要的字体大小即可，更换大屏显示器后将字体调回原本大小或者直接使用自动大小即可。</p>
<p><strong>火狐浏览器</strong>：将默认缩放大小设置为 120% 或 133%（或者自己需要的大小）即可，更换大屏显示器后将设置调回 100%</p>
<p><strong>Chrome</strong>：与 “火狐浏览器” 操作相同</p>
<h3 id="2-安装字体">2. 安装字体</h3>
<p>一般的设置按照自己的喜好自行设置即可。这里主要介绍一个操作：添加字体。主要是因为我写代码比较喜欢 Consolas 字体，但是 Ubuntu 里没有这个字体。</p>
<p>首先，我们需要下载需要的字体文件，一般是个压缩文件，我们将其解压即可；</p>
<p>然后我们在下面的文件夹新建一个字体文件夹：<code>/usr/share/fonts</code></p>
<p>然后将所有的<code>.ttf</code>文件移动到上一步自己新建的文件夹中即可。</p>
<p>然后修改字体权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 644 /usr/share/fonts/&lt;你刚才新建的文件夹&gt;/*.ttf</span><br></pre></td></tr></table></figure>
<p>然后进入到字体目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/fonts/&lt;你刚才新建的文件夹&gt;/</span><br></pre></td></tr></table></figure>
<p>刷新并安装字体：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkfontscale &amp;&amp; sudo mkfontdir &amp;&amp; sudo fc-cache -fv</span><br></pre></td></tr></table></figure>
<h2 id="六、-其他配置">六、 其他配置</h2>
<h3 id="1-禁用电脑自带键盘">1. 禁用电脑自带键盘</h3>
<p>由于为了节省空间，我常常需要把外接键盘放在笔记本上，但是很容易造成误触，所以需要将电脑自带键盘进行禁用，具体方法如下：</p>
<ul>
<li>
<p>首先打开终端，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xinput list</span><br></pre></td></tr></table></figure>
<p>如果没有 xinput 的话，按照指示安装即可</p>
</li>
<li>
<p>在 Ubuntu 22 下，通常这个命令执行之后会有一条错误信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WARNING: running xinput against an Xwayland server. See the xinput man page for details.</span><br></pre></td></tr></table></figure>
<p>这是因为 Ubuntu 22 默认使用了 Wayland 模式，导致 /etc/X11/xorg.conf.d/40-libinput.conf 不起作用，在这种情况下我们是无法正常禁用设备的，而且它也并不会把电脑自带键盘列出来，我们需要修改一下 /etc/gdm3/custom.conf 这个文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/gdm3/custom.conf</span><br></pre></td></tr></table></figure>
<p>可以先观察一下这个文件的内容，它的 WaylandEnable 这一项可能是 WaylandEnable=true 也可能直接注释掉了，如我的就是直接注释掉了，我们把该项前的注释符<code>#</code>删掉，然后确认一下 WaylandEnable 的值为 false 即可。</p>
<p>最后重启一下电脑。</p>
<p><strong>注意</strong>：不会使用 vim 编辑器的可以尝试使用 gedit，将上述命令中的 vim 替换为 gedit 即可，没有该软件的根据终端的提示进行安装。</p>
</li>
<li>
<p>在排除了问题之后，我们再次打开终端输入 <code>xinput list</code> 命令，正常情况下，输出就应该像下面这样全部输入输出设备都列出来了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sn@Program:~/桌面$ xinput list</span><br><span class="line">⎡ Virtual core pointer                    	id=2	[master pointer  (3)]</span><br><span class="line">⎜   ↳ Virtual core XTEST pointer              	id=4	[slave  pointer  (2)]</span><br><span class="line">⎜   ↳ MSFT0004:00 06CB:CD98 Mouse             	id=16	[slave  pointer  (2)]</span><br><span class="line">⎜   ↳ MSFT0004:00 06CB:CD98 Touchpad          	id=17	[slave  pointer  (2)]</span><br><span class="line">⎣ Virtual core keyboard                   	id=3	[master keyboard (2)]</span><br><span class="line">    ↳ Virtual core XTEST keyboard             	id=5	[slave  keyboard (3)]</span><br><span class="line">    ↳ Video Bus                               	id=6	[slave  keyboard (3)]</span><br><span class="line">    ↳ Power Button                            	id=7	[slave  keyboard (3)]</span><br><span class="line">    ↳ Integrated Camera: Integrated C         	id=12	[slave  keyboard (3)]</span><br><span class="line">    ↳ Ideapad extra buttons                   	id=15	[slave  keyboard (3)]</span><br><span class="line">    ↳ AT Translated Set 2 keyboard            	id=18	[slave  keyboard (3)]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>我们首先找到电脑自带键盘，一般名称都是 “AT Translated Set 2 keyboard”，我们需要使用该项后面的 id 值，我这里是 18，然后输入下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xinput set-prop 18 <span class="string">&quot;Device Enabled&quot;</span> 0</span><br></pre></td></tr></table></figure>
<p>即可禁用电脑自带键盘，命令中的 18 替换成你要禁用的设备在你自己的电脑上的 id 值，然后最后的值为 0 即为禁用，值为 1 即为启用，如，启用该设备的命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xinput set-prop 18 <span class="string">&quot;Device Enabled&quot;</span> 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>另外，使用命令禁用键盘之后，只要重启电脑，又会自动启用。如果想永久禁用的话，就把命令写入到 bashrc：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>添加高亮的两行即可：</p>
<p><img src="/images/Ubuntu%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/08.png" alt="08"></p>
<p>具体内容是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 禁用电脑自带键盘</span></span><br><span class="line">xinput set-prop <span class="string">&quot;AT Translated Set 2 keyboard&quot;</span> <span class="string">&quot;Device Enabled&quot;</span> 0</span><br></pre></td></tr></table></figure>
<p>这里使用设备的名称而不是用 id 值是因为 id 值可能发生变化。</p>
<p>接下来重启一下试试吧。</p>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>系统</tag>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows环境程序乱码问题</title>
    <url>//posts/b8fb1066/</url>
    <content><![CDATA[<h2 id="一、-前言">一、 前言</h2>
<h3 id="1-问题描述">1. 问题描述</h3>
<p>作为非英语国家的Windows用户，在Windows上进行编程想必都会遇到一个问题：中文乱码的问题。当然不只是中文，还有其他很多非英文国家也都有这个问题，这里仅以中文为例。</p>
<p>另外，乱码还有很多种类型，如常见的“锟斤拷”、“火星文”乱码等，它们的引发原因都是不同的。以及程序运行时还分为输入乱码以及输出乱码。我将对其进行详细的讨论。</p>
<h3 id="2-目标">2. 目标</h3>
<p>程序是程序员写的，是写给用户用的。我们需要抓住这里面的两个主要对象：</p>
<ul>
<li>
<p>用户：用户只想要以最轻松的方法就能正常使用软件，就像我们使用软件时只需要打开一个exe文件就可以了，一切复杂的操作都不要留给用户。</p>
<blockquote>
<p>这里一定要说的是：网络上有很多方法可以解决乱码问题，比如将Windows调成Beta版、终端在运行前通过chcp修改代码页或者是去注册表里修改终端的代码页属性等，这些工作做了确实有一定的效果（甚至有些效果都不完全），但是有哪个用户希望在使用你这个软件的时候去改这改那的，甚至还会影响到其他软件的运行。</p>
</blockquote>
</li>
<li>
<p>程序员：只想以最小的工作量完成需要的功能。</p>
<blockquote>
<p>为了解决乱码问题，我们当然可以将源文件就直接保存为GBK编码，然后编译的时候也按照GBK编译，最后的程序运行在GBK终端上，这样的方式当然是可以解决乱码问题，但是这样的程序只能给默认使用GBK编码的Windows系统的用户使用。为了使软件走向国际化，你还得为每一个有特殊代码页的国家编译一次甚至还得修改代码，最后让用户来选自己应该下载哪一个版本。这样既麻烦了程序员，又为用户带来了不必要的麻烦。</p>
<p>为了解决这个问题，我们可以使用Unicode编码，它可以表示全世界正在使用的所有字符并且还有空余位置。其中 UTF-8 编码应用最广，因为在所有Unicode编码中，只有UTF-8保证了除了空字符外，其余字符都不含0字节（这对使用C语言编程的程序比较友好，因为C语言程序通常以0字节表示字符串终止，如果在其他字符中包含0字节，可想而知，程序会将其自动识别为已终止，但实际上内容还没完）。</p>
</blockquote>
</li>
</ul>
<p>综上所述，我们最主要的一个目标就是如何编写一个UTF-8编码的程序并让其在任何终端环境都能正常运行。</p>
<h3 id="3-测试程序">3. 测试程序</h3>
<p>我们的测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你刚刚的输入是：%s\n&quot;</span>, name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序中既涉及到了输入，也涉及到了输出，我们可以同时测试两种类型的乱码，并根据乱码的类型来判断原因。</p>
<h3 id="4-影响因素">4. 影响因素</h3>
<p>在从源文件到软件程序的过程中，有几个因素都会影响最终程序的乱码与否，我们通过两个编译器来看比较典型的两个过程：</p>
<h4 id="1）MSVC编译器">1）MSVC编译器</h4>
<p>这是Visual Studio配套的一个编译器，如果不做任何修改，它的一个编译过程如下：</p>
<p><img src="/images/Windows%E7%8E%AF%E5%A2%83%E7%A8%8B%E5%BA%8F%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/01.jpg" alt="01"></p>
<p>其运行结果如下：</p>
<p><img src="/images/Windows%E7%8E%AF%E5%A2%83%E7%A8%8B%E5%BA%8F%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/02.png" alt="02"></p>
<p>所以在默认情况下，我们使用Visual Studio生成的程序可以完美地在自己的机器上执行。但由于其产生的目标程序使用GBK编码，而我们并不希望如此。</p>
<h4 id="2）GCC编译器">2）GCC编译器</h4>
<p>除了MSVC是默认使用GBK编码源文件之外，其他编译器基本上都是使用的UTF-8编码，不一定是GCC，但它比较有代表性，其典型过程如下图所示：</p>
<p><img src="/images/Windows%E7%8E%AF%E5%A2%83%E7%A8%8B%E5%BA%8F%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/03.jpg" alt="03"></p>
<p>其运行结果如下：</p>
<p><img src="/images/Windows%E7%8E%AF%E5%A2%83%E7%A8%8B%E5%BA%8F%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/04.png" alt="04"></p>
<h4 id="3）总结">3）总结</h4>
<p>从这上面的两个例子我们可以看到以下几点：</p>
<ul>
<li>对于中文<strong>输入</strong>来说，程序的编码与终端的编码是否相同对结果并没有什么影响，这是因为程序只保存编码后的字节信息，然后输出时将字节信息发送给终端，中间并不会经过什么处理。如果我们要在程序中处理中文字符，一般就不使用<code>char</code>来保存字符信息了，而使用宽字符。</li>
<li>源文件编码、编译器编码以及程序运行的终端这三个方面的共同作用会决定最后的程序是否会出现乱码。</li>
</ul>
<h3 id="5-配置-Visual-Studio（可选）">5. 配置 Visual Studio（可选）</h3>
<p>回过头来看我们想要达到的目标，使用UTF-8编码编写程序，生成的程序中使用UTF-8编码保存字符及字符串，最后能在任何编码环境的终端上正确运行。</p>
<p>很显然，上面的第二种过程（GCC）比较适合我们要讨论的内容（虽然它的输出暂时有问题），后面也将主要使用这种方法来进行测试。但对于第一种过程（MSVC）也是可以调整成与第二种过程相同的。</p>
<p>对于仅开发面向于使用GBK编码的Windows用户的程序来说，当然使用其原本的配置就可以了，生成的程序也能完美的在这样的主机上运行。但如果是想使用UTF-8编码或者有软件国际化需求的程序员来说，也可以像下面这样将MSVC配置成与GCC编译（编码上）相同的过程：</p>
<h4 id="1）保证文件的编码">1）保证文件的编码</h4>
<p>我们首先需要做的就是保证文件的编码是UTF-8编码。</p>
<ul>
<li>
<p>第一步是开启查看当前的文件的编码的设置项</p>
<p>主要目标是开启【文件】菜单栏下的【高级保存选项】的选项。以下是操作过程（过程比较多就不用截图的方式了）：</p>
<p>【工具】-&gt;【自定义】-&gt;【命令】-&gt; 在【菜单栏】右侧的下拉框中选择【文件】-&gt;【添加命令】-&gt;【文件】-&gt; 在右侧找到【高级保存选项】-&gt; 点击【确定】即可添加</p>
<blockquote>
<p>开启该功能后就可以在【文件】菜单栏下找到【高级保存选项】了，将文件打开并进入编辑状态就可以打开该选项，就可以看到该文件的编码了。</p>
<p>通常在新建项目时，Visual Studio自动创建的文件都是UTF-8编码的，而自己新建的文件都是GBK编码的。</p>
</blockquote>
</li>
<li>
<p>接下来是强制将文件按照UTF-8进行保存</p>
<p>在这一步我们需要去下载一个插件，叫做 “Force UTF-8 (With BOM) 2022” 或者 “Force UTF-8 (No BOM) 2022”，这两者都可以，区别在于第一个会在文件前面添加签名标识文件的编码。</p>
<p>安装好并重启软件之后它就开始生效了。我们新创建一个文件，这时去查看它的编码应该仍然是GBK编码，我们点击一下保存，然后将文件叉掉再重新打开就可以看到它已经变成UTF-8编码了</p>
</li>
</ul>
<h4 id="2）更改MSVC的编码">2）更改MSVC的编码</h4>
<p>这一步完成之后，使用MSVC的过程就和使用GCC的过程（在编码上）基本一致了，其具体操作如下：</p>
<p>打开【项目属性】-&gt;【配置属性】-&gt;【C/C++】-&gt;【命令行】-&gt; 在【其他选项】中输入<code>/utf-8</code> -&gt;【确定】/【应用】即可</p>
<h4 id="3）测试">3）测试</h4>
<p>测试结果如下：</p>
<p><img src="/images/Windows%E7%8E%AF%E5%A2%83%E7%A8%8B%E5%BA%8F%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/05.png" alt="05"></p>
<p>可以看到，其输出结果和GCC过程相同了。</p>
<h2 id="二、-分析、方法及测试">二、 分析、方法及测试</h2>
<h3 id="1-分析">1. 分析</h3>
<h4 id="1）乱码的决定性环节">1）乱码的决定性环节</h4>
<p>我们需要分析的是，在文件、编译器、终端这三者之间，哪些的编码可以一致。</p>
<ul>
<li>
<p>首先是三者都相同，也就是默认状态下的MSVC的过程，虽然源文件可以是其他编码，但它最后会被MSVC转换成GBK编码</p>
</li>
<li>
<p>其次是二者相同的情况</p>
<ul>
<li>如果文件和编译器相同，那么可执行程序中的字符及字符串按照源文件编码保存，当终端编码与前二者不同时，将会产生乱码</li>
<li>如果编译器和终端相同，那么源文件的字符及字符串被解释为另一种编码，但二进制内容还是不变。然后按照被解释的编码进行输出，结果显然是乱码。</li>
<li>如果文件和终端相同（假设都为GBK），那么可执行程序中的字符在源文件中是GBK，而经过了编译器的转换，现在是UTF-8编码，但是虽然二者的解释不同，但是它们的内容还是一样的，所以当使用GBK编码的终端执行程序时，可执行程序中的UTF-8编码又被解释回了GBK编码，于是程序能够正常输出并且正常输入。</li>
</ul>
<p><strong>综上所述，实际上最终是否有乱码并不受编译器编码的影响，而只取决于源文件与终端二者的编码是否一致。</strong></p>
</li>
<li>
<p>最后是三者都不同的情况，根据我们刚才的结论，很明显这个会出现乱码</p>
</li>
</ul>
<h4 id="2）确定方向">2）确定方向</h4>
<p>根据上面所得出的结论，我们要做的就是让源文件编码和终端编码相同，而我们的目标是编写UTF-8程序并在所有环境的终端上都能正常运行。</p>
<p>所以很显然，我们的源文件应该是UTF-8编码的，而终端则可以是任何编码的。显然在这种情况下如果我们什么都不做，那么最终结果一定会出现乱码。</p>
<p>为了解决这个矛盾，我能想到的唯一（同时不麻烦用户）的办法就是<strong>在程序中插入代码改变运行环境</strong>。</p>
<h4 id="3）终端输入输出编码不统一">3）终端输入输出编码不统一</h4>
<p>根据上面的改进方向看上去很容易可以完成这样的修改，网上也有很多这样的方法，比如<code>chcp 65001</code>之类的方法。但使用<code>chcp</code>来修改终端代码页的方法经测试只能修改其输出编码，但是输入编码仍然是GBK，然后最后通过终端输出时又成了UTF-8编码，从而导致输入的回显乱码。</p>
<p>这也导致Windows终端编码的问题异常的难以解决。</p>
<h3 id="2-测试准备">2. 测试准备</h3>
<h4 id="1）测试代码">1）测试代码</h4>
<p>基本上还是上面的代码，不过经过了细微的修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的输入是：%s\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符数：%d\n&quot;</span>, <span class="built_in">strlen</span>(name));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是添加了一条语句计算输入字符串的长度，这条语句的本意是为了判断程序是否成功读取了内容，而不是真的为了计算输入的字符数量，毕竟汉字也不是单个字节。加上这一条的原因是在后面的测试中，有时会无法读取，为了判断是否刚好是空白乱码，所以添加了这样一句。</p>
<h4 id="2）乱码类型及原因">2）乱码类型及原因</h4>
<p>如下表所示：</p>
<table>
<thead>
<tr>
<th>乱码类型</th>
<th>示例</th>
<th>产生原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>古文码</td>
<td>鐢辨湀瑕佸ソ濂藉涔犲ぉ澶╁悜涓?</td>
<td>以GBK的方式读取UTF-8编码的中文</td>
</tr>
<tr>
<td>口字码</td>
<td>����Ҫ�¨²�ѧϰ������</td>
<td>以UTF-8的方式读取GBK编码的中文</td>
</tr>
<tr>
<td>符号码</td>
<td>ç”±æœˆè¦�å¥½å¥½å­¦ä¹ å¤©å¤©å�‘ä¸Š</td>
<td>以ISO8859-1方式读取UTF-8编码的中文</td>
</tr>
<tr>
<td>拼音码</td>
<td>ÓÉÔÂÒªºÃºÃÑ§Ï°ÌìÌìÏòÉÏ</td>
<td>以ISO8859-1方式读取GBK编码的中文</td>
</tr>
<tr>
<td>问句码</td>
<td>由月要好好学习天天向??</td>
<td>以GBK方式读取UTF-8编码的中文，<br />然后又用UTF-8的格式再次读取</td>
</tr>
<tr>
<td>锟拷码</td>
<td>锟斤拷锟斤拷要锟矫猴拷学习锟斤拷锟斤拷锟斤拷</td>
<td>以UTF-8方式读取GBK编码的中文，然后又用GBK的格式再次读取</td>
</tr>
</tbody>
</table>
<h3 id="2-5-测试前问题【严重】">2.5. 测试前问题【严重】</h3>
<p>我们的改进目标是在源文件中插入代码然后让程序本身在开始运行的时候自发改变运行环境，从而适应不同编码环境的终端，而其自发改变运行环境的最终目标当然是和源文件编码相同即UTF-8编码。</p>
<p>于是我在一个完全UTF-8编码的环境下进行了测试（我搭建了一台Windows虚拟机并在区域设置里调成了Beta版）。在其他环境下，即使通过调整使输出正常了，但输入却老是会出现乱码问题，这主要是源于前面所提到的一些方法只能改变终端的输出编码而导致终端输入输出编码的不同以致于乱码。</p>
<p>我想至少先在完全UTF-8编码的环境下进行测试，如果能正常输入输出，至少证明我们的方向是对的。但非常令人难以接受的是，即使在这样的环境下，程序仍然出错了。这一次不再是乱码错误，而是根本无法接收输入（表面上是这样），并且不论是MinGW还是MSVC编译的程序，效果都一样。</p>
<p>在调试之后，发现了问题所在，在完全UTF-8编码的机器上运行该程序，中文能够正常输出，但是输入的中文却无法正常读取，在调试过程中我发现所有的中文字符都被读取为了空字符（注意并不只有开头是空字符，是整个中文字符都被识别为了空字符，它们只在空字符数量上有区别），即使我将<code>scanf</code>函数改为了<code>fgets</code>函数，效果也是一样，<code>name</code>数组中被覆盖了的字节都是空字符（偶尔会有换行符），从而导致了读取的内容无法正常输入或者说是读取出错。</p>
<p>虽然找到了表面问题所在，但我对解决这个问题的方法却完全没有头绪。当我去问AI的时候，它告诉我可能是因为Windows的运行时库的影响，但没有任何具体的措施去解决。</p>
<p>综上原因，导致我无法确认后续所提出的方法是否达到了正确的效果。所以后续测试中如果出现输入乱码问题，我会对其进行分析；但如果出现输出读取问题，我就无法解释了。</p>
<h3 id="3-方法及测试">3. 方法及测试</h3>
<div class="tabs" id="methods"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#methods-1">chcp法</button></li><li class="tab"><button type="button" data-href="#methods-2">Win32 API法</button></li><li class="tab"><button type="button" data-href="#methods-3">setlocale法</button></li><li class="tab"><button type="button" data-href="#methods-4">添加字符转换层功能</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="methods-1"><ul>
<li>
<p>说明</p>
<p>先说明，此处的chcp法和我在前言部分提到的chcp法不同，那种方法是用户执行chcp改变终端环境，很明显违背了用户的需求，而且经过实测那一种方法实际上仍然有问题，如我在执行该命令后，再运行程序仍然输出乱码。</p>
</li>
<li>
<p>此处的chcp法是在程序内添加<code>system</code>函数来执行该指令，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;chcp 65001&quot;</span>);</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的输入是：%s\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符数：%d\n&quot;</span>, <span class="built_in">strlen</span>(name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要改动是添加了头文件<code>&lt;stdlib.h&gt;</code>以及一条<code>system</code>函数调用。</p>
</li>
<li>
<p>其运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Active code page: 65001</span><br><span class="line">你好</span><br><span class="line">你的输入是：��</span><br><span class="line">输入字符数：2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>分析</p>
<p>根据结果可以看出，其输出正常，但输入出现乱码。输入乱码则首先说明一点，就是终端的输入输出编码不一致，具体的原因根据前面的乱码类型表可以知道是以UTF-8的方式读取了GBK编码的中文。</p>
<p>输出正常说明输出编码是UTF-8编码，不难猜出输入编码应该还是GBK编码。实际也确实如此，我们输入的中文被终端转换为GBK编码然后原封不动保存到程序，最后程序交给终端这些数据之后，终端又以UTF-8编码输出该字符数据，从而导致以UTF-8的方式读取GBK编码的中文。</p>
</li>
<li>
<p>解决方法</p>
<p>暂时并没有该问题的（并且满足用户需求的）解决方案，同时也并不建议大家使用这个方法。首先就是因为输入编码与输出不一致的原因；其次如果你只是开发Windows程序的话倒是没什么大问题，但是如果你同时希望程序能够在Linux上编译运行成功，就不能这样做，因为Linux上没有chcp命令，当然也可以在代码中添加条件判断来做兼容，但这样就又会变得麻烦了一点。</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="methods-2"><ul>
<li>
<p>说明</p>
<p>该方法是使用<code>&lt;Windows.h&gt;</code>头文件中的函数来改变终端的环境</p>
</li>
<li>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOMINMAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SetConsoleCP(CP_UTF8);</span><br><span class="line">    SetConsoleOutputCP(CP_UTF8);</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的输入是：%s\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符数：%d\n&quot;</span>, <span class="built_in">strlen</span>(name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加了两个宏、一个头文件以及两条语句。</p>
</li>
<li>
<p>运行结果</p>
<p>此处运行结果非常奇怪，所有的输入最后都返回同样的乱码，有些甚至不算乱码，也就是一般的字符，但无一例外每次都返回相同的字符，在每一次重新启动终端后，返回的字符会发生变化，甚至有一次还复现了在本部分2.5节所提到的运行结果，或许二者有一定的关联。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">你好</span><br><span class="line">你的输入是：PP</span><br><span class="line">输入字符数：2</span><br><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">乱码测试</span><br><span class="line">你的输入是：PPPP</span><br><span class="line">输入字符数：4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">你好</span><br><span class="line">你的输入是：@@</span><br><span class="line">输入字符数：2</span><br><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">乱码测试</span><br><span class="line">你的输入是：@@@@</span><br><span class="line">输入字符数：4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">你好</span><br><span class="line">你的输入是：��</span><br><span class="line">输入字符数：2</span><br><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">乱码测试</span><br><span class="line">你的输入是：����</span><br><span class="line">输入字符数：4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">你好</span><br><span class="line">你的输入是：</span><br><span class="line">输入字符数：0</span><br><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">乱码测试</span><br><span class="line">你的输入是：</span><br><span class="line">输入字符数：0</span><br></pre></td></tr></table></figure>
<p>大致就是这4种结果，其中最后一种出现的比较少。通常在同一个终端里，一直运行该程序，其输出的字符都是同一种字符，如果重启了终端，则可能会变成另一种输出类型。另外如果开启两个终端交叉执行该程序，在同一个终端里，最后输出的结果也可能发生变化，但无一例外，每个单次输出的结果都是同一个字符。</p>
</li>
<li>
<p>解决方法</p>
<p>无法分析该结果</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="methods-3"><ul>
<li>
<p>说明</p>
<p>该方法使用标准库中的<code>setlocale</code>函数</p>
</li>
<li>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setlocale(LC_ALL, <span class="string">&quot;.utf-8&quot;</span>);</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的输入是：%s\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符数：%d\n&quot;</span>, <span class="built_in">strlen</span>(name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加了一个头文件及一条语句。</p>
</li>
<li>
<p>输出</p>
<p>我使用该方法得到的程序也有些问题，首先如果使用MinGW生成的程序，那么<code>setlocale</code>不生效，即输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">你好</span><br><span class="line">浣犵殑杈撳叆鏄細你好</span><br><span class="line">杈撳叆瀛楃鏁帮細4</span><br></pre></td></tr></table></figure>
<p>而如果使用Visual Studio生成程序，则其得到的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你好</span><br><span class="line">你的输入是：输入字符数：4</span><br></pre></td></tr></table></figure>
<p>真的是让人匪夷所思，它看上去成功读取了内容，因为最后显示长度为 4，但包含在源代码里的格式它都给我改了，它读取到的内容本身没有输出也就算了，我<code>printf</code>里的<code>\n</code>也没有输出，难道说读取内容的时候还把内存里的数据给改了？我尝试增加了<code>name</code>数组的大小也使用了Windows的<code>scanf_s</code>函数，但结果仍然没有任何改变。</p>
</li>
<li>
<p>解决方法</p>
<p>问题无法分析，解决方法无</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="methods-4"><p>该方法与前面三种方法对比，目前算是最靠谱的一种方法，具体的措施就是在程序和用户界面之间添加一层字符转换功能，这样同时也就不用改变用户终端环境，虽然和我们最开始决定的方向有所区别，但确确实实能解决问题，而且事实也证明改变用户终端环境的方法会出现很多问题。</p>
<p>而且第一中方法所得到的输入的字符还会出现一个问题（2、3种方法由于无法分析其输入错误的原因所以不做讨论）：在我们的程序只需要输出，并不会对输入进行回显但是却需要处理用户的中文输入的时候，我们将无法处理，因为我们在程序中将按照uft-8的编码（如果是宽字符，则一般是Unicode编码）进行处理，然而此时我们所获取到的用户输入确实GBK的编码，很显然在处理过程中会出现错误。而这种方法也同时解决了这样的问题。</p>
<p>它的具体过程如下所示：</p>
<p><img src="/images/Windows%E7%8E%AF%E5%A2%83%E7%A8%8B%E5%BA%8F%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/06.jpg" alt="06"></p>
<p>还是简单做了个测试，过程如下：</p>
<ul>
<li>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;convert.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 输出字符串定义与转换</span></span><br><span class="line">    <span class="type">char</span> firstOut_utf8[] = <span class="string">&quot;你输入的是：&quot;</span>;      <span class="comment">// 定义输出字符串（与源文件编码相同，即utf8）</span></span><br><span class="line">    <span class="type">char</span> secondOut_utf8[] = <span class="string">&quot;输入字符数：&quot;</span>;     <span class="comment">//</span></span><br><span class="line">    <span class="type">char</span> firstOut_gbk[<span class="number">20</span>];                     <span class="comment">// 用于保存编码转换后的输出字符串</span></span><br><span class="line">    <span class="type">char</span> secondOut_gbk[<span class="number">20</span>];                    <span class="comment">//</span></span><br><span class="line">    utf8ToGbk(firstOut_utf8, <span class="built_in">strlen</span>(firstOut_utf8), firstOut_gbk, <span class="number">20</span>);</span><br><span class="line">    utf8ToGbk(secondOut_utf8, <span class="built_in">strlen</span>(secondOut_utf8), secondOut_gbk, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入字符串定义与转换</span></span><br><span class="line">    <span class="type">char</span> name_gbk[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name_utf8[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name_unicode[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name_gbk2[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name_gbk);</span><br><span class="line">    gbkToUtf8(name_gbk, <span class="built_in">strlen</span>(name_gbk), name_utf8, <span class="number">20</span>);</span><br><span class="line">    multibyteToUnicode(name_utf8, <span class="built_in">strlen</span>(name_utf8), CP_UTF8, name_unicode, <span class="number">20</span>);</span><br><span class="line">    unicodeToMultibyte(name_unicode, <span class="built_in">strlen</span>(name_unicode), name_gbk2, <span class="number">20</span>, CP_ACP);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s%s\n&quot;</span>, firstOut_gbk, name_gbk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s%d\n&quot;</span>, secondOut_gbk, <span class="built_in">strlen</span>(name_gbk2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在头文件<code>convert.h</code>就是几个字符编码转换函数，主要有<code>utf8ToGbk</code>、<code>gbkToUtf8</code>（提供 UTF-8 和 GBK 之间的转换），以及<code>multibyteToUnicode</code>、<code>unicodeToMultibyte</code>（提供多字节编码（GBK、UTF-8）与 Unicode 编码之间的转换）。</p>
<p>在程序中可以看到，在输出字符串部分，我首先是定义了需要直接输出的字符串，然后用转换函数将其从UTF-8转换成了GBK；在输入字符串部分，首先是将获取到的gbk输入转换成<code>utf8</code>，再转换成<code>Unicode</code>，最后再转换回GBK（看上去是做的无用功，实际上确实也是，在这里主要是更突出一下这个转换函数确实是有作用的）。最后将都转换成GBK编码的字符串输出。</p>
</li>
<li>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe     </span><br><span class="line">你好</span><br><span class="line">你输入的是：你好</span><br><span class="line">输入字符数：4</span><br><span class="line">PS C:\Users\tangc\source\vscode&gt; .\a.exe</span><br><span class="line">乱码测试</span><br><span class="line">你输入的是：乱码测试</span><br><span class="line">输入字符数：8</span><br></pre></td></tr></table></figure>
<p>非常成功</p>
</li>
</ul>
<p>需要说明的是，这里的测试代码仅仅只是用于测试，包括头文件中的几个函数实际上都是非常不成熟的，毕竟没有人在使用<code>printf</code>之前先将需要输出的内容定义好；另外，如果是一个成熟的功能，我认为它至少还应该能够自动识别当前用户字符编码环境，然后提供程序与用户界面之间字符编码的自动转换，这样不仅让用户好用，也让程序员好写。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="三、-结论">三、 结论</h2>
<p>以上的几种方法是我在网上搜集到的一些方法，它们都能够比较好的解决输出乱码的问题，但是输入回显的乱码问题却仍然得不到解决。</p>
<p>在前三种方法中我原本最看好的是第三种，因为它不依赖与系统，但实际测试中却不知为何MinGW编译出的程序<code>setlocale</code>不生效，以及即使使用Visual Studio生成的程序<code>setlocale</code>生效了，但它似乎带来了比乱码更麻烦的问题。</p>
<p>第四种方法是当前比较完美的一种解决方案，该方案是在一位B站up主的帮助下获得的启发，已将其B站主页链接在文末。</p>
<hr>
<p>以上内容主要参考了该文章：<a href="https://zhuanlan.zhihu.com/p/627531212">记录Windows下开发C/C++如何避免乱码</a></p>
<p>以及非常感谢B站up主<a href="https://space.bilibili.com/356450253?spm_id_from=333.999.0.0">喜欢运动衫的帅帅</a>的帮助</p>
]]></content>
      <categories>
        <category>Windows</category>
        <category>字符集</category>
      </categories>
      <tags>
        <tag>系统</tag>
        <tag>Windows</tag>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title>链接库的生成与使用</title>
    <url>//posts/f65fc406/</url>
    <content><![CDATA[<h2 id="一、-前言">一、 前言</h2>
<p>在实际工程中，生成与使用链接库是比较常用的操作，本文将从以下几个方面来介绍链接库的生成与使用：</p>
<ul>
<li>程序的编译过程：这一部分算是链接库的前提知识，当我们清晰地了解了整个编译过程的实际编译阶段之后，我们才能比较好地了解链接库的工作过程。</li>
<li>认识链接库：主要讲解链接库的两个类别：动态链接库和静态链接库，以及它们的工作过程。</li>
<li>静态链接库的生成与使用：如题所示，就是讲静态链接库怎么生成使用</li>
<li>动态链接库的生成与使用：同上</li>
</ul>
<p>同时，本文将通过引用的格式写一些对理解有帮助的 tips，这些 tips 有些人可能很清楚，但是有些人根本不了解（比如我），具体的格式就像下面这样：</p>
<blockquote>
<p><strong>tip</strong>：</p>
<p>…</p>
</blockquote>
<h2 id="二、-编译过程">二、 编译过程</h2>
<p>当我们第一次使用 gcc 这个编译器的时候，一般执行的第一个命令就是：<code>gcc main.c</code>，它将我们的源文件 <code>main.c</code> “编译” 后生成了一个可执行文件：<code>a.out</code>（Windows下为<code>a.exe</code>）。于是，很多人可能就会有一个误解：编译就一个步骤，即编译本身。</p>
<p>但实际上整个编译过程并非只有一个步骤，而是由以下几个步骤组成：</p>
<p>假设我们有一个程序<code>main.c</code>如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后执行以下命令：<code>gcc main.c</code>，然后 gcc 编译器就会执行下面的步骤：</p>
<div class="tabs" id="compile_process"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#compile_process-1">预处理</button></li><li class="tab"><button type="button" data-href="#compile_process-2">编译</button></li><li class="tab"><button type="button" data-href="#compile_process-3">汇编</button></li><li class="tab"><button type="button" data-href="#compile_process-4">链接</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="compile_process-1"><p>该过程将所有的<code>#define</code>、<code>#include</code>等进行替换。</p>
<blockquote>
<p><strong>库和头文件的区别</strong>：</p>
<p>相信很多刚开始学习计算机知识以及刚开始学习 C 语言或 C++ 的小伙伴一定对这两个名词很疑惑，理解起来很混乱。</p>
<p><strong>头文件</strong>大家都不陌生，能够通过<code>#include</code>包含的都算是头文件，但是我们在包含<code>&lt;stdio.h&gt;</code>这类标准库的时候，为什么要叫它标准库而不是标准头文件呢。</p>
<p>了解过面向对象编程的小伙伴都知道我们经常要将类型的接口和实现分离，为的就是对类型进行封装，在不暴露其实现细节的情况下为别人提供服务，而这个封装的方法就是通过库来进行，通过将类型或函数的实现生成为库（这个后面会讲），程序在包含这个头文件之后就看不到具体的实现了，只能看到头文件提供的接口（也就是类型的成员以及提供的函数接口）。</p>
<p>而标准库就是这么一个东西，我们包含的<code>&lt;stdio.h&gt;</code>里面只有它提供的接口，如一些常用的函数<code>printf</code>、<code>scanf</code>等等，但是这些函数的实现并不在这个头文件里，而在一个叫做 C 语言标准库的库文件里，这个库在整个编译过程的链接阶段会用到。</p>
<p>而我们包含的<code>&lt;stdio.h&gt;</code>只为我们提供接口，预处理的过程就是将这个文件里的内容粘贴到<code>#include &lt;stdio.h&gt;</code>所在的位置，相当于为我们的<code>main.c</code>提供了<code>printf</code>、<code>scanf</code>等函数的函数声明，方便我们接下来使用这些函数。</p>
</blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="compile_process-2"><p>将预处理之后的<code>main.c</code>进行编译过程，这个编译过程通常是根据当前的机器将源文件翻译成对应的汇编程序源文件，用后缀<code>.s</code>表示，即<code>main.c</code>被翻译为<code>main.s</code>，这个文件是汇编语言写成的程序。之所以要进行这一步，是因为在不同的机器上，相同指令的机器代码是不同的。我们使用的 C/C++ 语言则是高度抽象的语言，不因机器而异，但是我们最终得到的可执行程序却与机器相关，所以我们首先需要将其转换成与机器相关的文件。汇编语言是机器码的第一层抽象，也与机器相关，所以我们将 C 语言源文件先翻译成汇编语言源文件，然后再生成可执行文件</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="compile_process-3"><p>也就是将上一步我们得到的汇编语言源文件进行汇编得到一个后缀为<code>.o</code>的文件，即<code>main.o</code>，这类文件叫做<strong>可重定向目标文件</strong>，这个文件里面已经就是我们的机器将要执行的机器码了，是一个二进制文件，但为什么不是<code>a.out</code>或者说是<code>a.exe</code>文件呢？因为整个编译过程还有一个阶段没做</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="compile_process-4"><p>这一步对于 C/C++ 语言的初学者来说好像基本上遇不到，但实际上你编写的几乎每个程序都有这个过程，因为我们免不了使用标准库提供的函数。如果我们使用非标准库也就是第三方库，那么在 gcc 的命令中需要显式地链接这个库文件，这个库文件里就是我们之前包含的一个只有接口没有实现的头文件的实现部分。而只使用标准库的文件为什么在 gcc 命令中不需要显式地链接呢？其原因就是因为几乎每个程序都需要用到标准库提供的函数，而每一次使用 gcc 命令都要显式链接一下标准库实在太麻烦了，所以 gcc 都是隐式地链接了标准库，就不需要我们再动手链接了。在链接好之后我们就可以得到最终的可执行程序了，即<code>a.out</code>或<code>a.exe</code></p>
<p>我们可以在终端执行下面的命令来看一下我们最终得到的可执行程序的依赖，也就是它需要链接的库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldd a.out</span><br></pre></td></tr></table></figure>
<p>可以得到下面的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sn@Program:~/桌面/Test$ ldd a.out </span><br><span class="line">	linux-vdso.so.1 (0x00007ffd0315f000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd4e1a41000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007fd4e1c7d000)</span><br></pre></td></tr></table></figure>
<p><code>linux-vdso.so.1</code>和<code>/lib64/ld-linux-x86-64.so.2</code>在本文中不涉及，中间的<code>/lib/x86-64-linux-gnu/libc.so.6</code>这个文件也就是我们的标准库，里面的内容就是我们使用的标准库函数的实现部分。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="三、-认识链接库">三、 认识链接库</h2>
<h3 id="1-链接库类型">1. 链接库类型</h3>
<p>链接库分为两类：静态链接库和动态链接库</p>
<p>静态链接库用后缀 <code>.a</code>（Linux）或 <code>.lib</code>（Windows）表示</p>
<p>动态链接库用后缀 <code>.so</code>（Linux）或 <code>.dll</code>（Windows）表示</p>
<p>接下来我们就来具体认识一下这两种库，整个认识过程将从库的生成到使用以及库的工作过程来说明。</p>
<div class="tabs" id="libriry"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#libriry-1">静态链接库</button></li><li class="tab"><button type="button" data-href="#libriry-2">动态链接库</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="libriry-1"><p>在建立静态链接库之前，我们首先需要写好一些文件：</p>
<ul>
<li>作为接口的头文件</li>
<li>接口的实现</li>
</ul>
<p>然后将以上两类文件处理（处理的具体方法后面会讲）之后，我们就可以得到一个静态链接库（<code>.a</code>或<code>.lib</code>），然后库的提供者将两份文件提供给库的使用者：</p>
<ul>
<li>接口头文件：是和上面的同一个头文件</li>
<li>静态链接库文件：已经将接口的实现部分编译为二进制文件并打包了起来，使用者可以通过链接该文件得到实现的部分。</li>
</ul>
<p>库的使用者如果要使用这个库，那就需要做两件事：</p>
<ul>
<li>首先包含库的提供者提供的接口头文件：里面只有接口也就是类型、类型成员和函数的声明。包含该文件之后，使用者才能正常使用其提供的类型和函数</li>
<li>在编译时需要将库文件加入到命令中</li>
</ul>
<p>然后在整个编译过程中，gcc 就会做如下工作：</p>
<ul>
<li>预处理：将接口头文件的内容粘贴到包含的地方</li>
<li>编译、汇编</li>
<li>链接：将使用到的接口头文件中的函数的代码从库文件中复制到可重定向目标文件中</li>
</ul>
<p>最后就生成了一个可执行文件，在执行过程中，由于所有的代码都已经在可执行文件中了，所以不论库的位置是否变化，或者是否删除该库，这个可执行文件都能正常执行。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="libriry-2"><p>在建立动态链接库之前，我们需要准备好和静态链接库相同的文件：</p>
<ul>
<li>接口头文件（在 Windows 中这个头文件需要做一些处理）</li>
<li>接口的实现</li>
</ul>
<p>然后将以上两类文件处理之后，我们就可以得到一个动态链接库（<code>.so</code>或<code>.dll</code>，Windows 下还会生成一个<code>.lib</code>作为导入库，注意不是静态库），然后库的提供者将以下文件提供给库的使用者：</p>
<ul>
<li>接口头文件</li>
<li>动态链接库文件</li>
<li>如果是 Windows 还需要将导入库文件一并给出</li>
</ul>
<p>库的使用者如果要使用这个库，应该如下操作：</p>
<ul>
<li>包含接口头文件</li>
<li>在编译时需要将 动态链接库文件（Linux）或 导入库文件（Windows）加入到命令中</li>
</ul>
<p>然后在编译过程中，gcc 的工作如下：</p>
<ul>
<li>预处理、编译、汇编</li>
<li>链接：将使用到的接口头文件中的函数从库文件中映射一个地址到可重定向目标文件中</li>
</ul>
<p>最后得到可执行程序，进行执行。在执行过程中，当遇到接口中的函数时，程序就会跳转到对应的动态库中的相应地址进行执行。所以如果动态链接库的位置变动或删除，这个可执行程序都将无法正常运行。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="2-二者的区别">2. 二者的区别</h3>
<p>通过上面的介绍，我们不难总结出静态链接库与动态链接库的区别：</p>
<div class="tabs" id="differences"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#differences-1">文件名</button></li><li class="tab"><button type="button" data-href="#differences-2">生成及使用操作</button></li><li class="tab"><button type="button" data-href="#differences-3">链接方式</button></li><li class="tab"><button type="button" data-href="#differences-4">目标文件</button></li><li class="tab"><button type="button" data-href="#differences-5">执行过程</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="differences-1"><p>静态库的后缀是<code>.a</code>或<code>.lib</code></p>
<p>而动态库的后缀是<code>.so</code>或<code>.dll</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="differences-2"><p>具体内容请见下文</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="differences-3"><p>静态库是将实现代码复制到可执行文件中</p>
<p>动态库是将实现代码的地址映射到可执行文件中</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="differences-4"><p>很显然依赖静态链接库比起依赖动态链接库的程序要更大</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="differences-5"><p>依赖静态库的程序执行过程中不再需要所依赖的库文件</p>
<p>依赖动态库的程序执行过程中需要所依赖的库文件</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="3-关于后文">3. 关于后文</h3>
<p>本文将着重说明使用 gcc 生成静态库和动态库的方法以及使用的方法，所以其实是着重说明 Linux 下的生成与使用方法。</p>
<p>在 Windows 下也可以使用 gcc 按照与 Linux 相同的方法使用动态库和静态库，或许有些许的区别。但是这不是正常的 Windows 生成和使用链接库的方法，比如在 Windows 中生成一个动态库应该会生成两个文件，一个<code>.dll</code>的动态库文件和一个<code>.lib</code>的导入库文件，但是使用 gcc 就值生成一个<code>.dll</code>文件。当脱离了标准，使用就会变得困难，比如我如果使用 gcc 生成一个动态库，然后将这个动态库交给别人，那么别人在拿到这个动态库的时候就只有接口头文件和一个<code>.dll</code>文件，并没有<code>.lib</code>的导入库文件，那么拿到这个库的人如果环境中没有安装 gcc，那么他可能无法正常使用这个动态库。综上所述，我不会讲解在 Windows 下使用 gcc 生成动态库和静态库的方法。</p>
<p>所以后文将分成两部分，一部分是在 Linux 下的链接库的生成与使用方法，使用编译工具 gcc；另一部分是在 Windows 下的链接库的生成与使用方法，使用 Visual Studio IDE，本文不包含该 IDE 的使用方法。</p>
<h2 id="四、-链接库的生成与使用（Linux）">四、 链接库的生成与使用（Linux）</h2>
<h3 id="1-文件">1. 文件</h3>
<p>我将用下面的文件进行演示，为了便于理解，这些函数都很简单。</p>
<ul>
<li>
<p>接口头文件：simple.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* simple.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数加法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数减法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数乘法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">multi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接口实现：add_minus.c、multi.c</p>
<p>这里用两个文件进行实现是为了演示多文件编译的过程，正常情况下在一个文件中进行实现即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* add_minus.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;simple.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* multi.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;simple.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>测试文件：test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* test.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;simple.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, a, b, add(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %d = %d\n&quot;</span>, a, b, minus(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %d = %d\n&quot;</span>, a, b, multi(a, b));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-静态链接库的生成与使用">2. 静态链接库的生成与使用</h3>
<h4 id="1）生成">1）生成</h4>
<ul>
<li>
<p>所需文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── add_minus.c</span><br><span class="line">├── mutli.c</span><br><span class="line">└── simple.h</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>操作</p>
<ul>
<li>
<p>首先将接口实现编译成可重定向目标文件：通过 gcc 的 -c 选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c add_minus.c multi.c</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后将这些可重定向目标文件打包成静态库：通过 ar 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ar -crv libsimple.a add_minus.o multi.o</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<code>libsimple.a</code>是我们需要的静态库的名字，命名规范是：<code>libXXX.a</code>，<code>XXX</code>是我们自己起的库的名字</p>
</li>
<li>
<p>于是我们得到了<code>libsimple.a</code>这个静态库文件。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2）使用">2）使用</h4>
<p>在生成这一部分完成之后，我们的文件夹应该如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── add_minus.c</span><br><span class="line">├── add_minus.o</span><br><span class="line">├── libsimple.a</span><br><span class="line">├── mutli.c</span><br><span class="line">├── mutli.o</span><br><span class="line">└── simple.h</span><br></pre></td></tr></table></figure>
<p>为了模拟实际工程中我们使用第三方静态库的情况，我们只从中抽取出两个文件：simple.h、libsimple.a 并加入一个测试程序源文件 test.c。</p>
<ul>
<li>
<p>所需文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── libsimple.a</span><br><span class="line">├── simple.h</span><br><span class="line">└── test.c</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>操作：直接执行下面的命令即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc test.c libsimple.a -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：可以看到我们使用静态库的方法就跟多源文件编译的方法相同，就是把库文件当成一个源进行编译。</p>
<p>最终生成可执行文件 test</p>
</li>
<li>
<p>执行测试</p>
<ul>
<li>
<p>正常测试</p>
<p>我们来执行起来看一下：输入命令<code>./test</code>，输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sn@Program:~/桌面/Test$ ./test </span><br><span class="line">请输入两个整数：</span><br></pre></td></tr></table></figure>
<p>我们输入两个整数进行测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sn@Program:~/桌面/Test$ ./test </span><br><span class="line">请输入两个整数：5 3 </span><br><span class="line">5 + 3 = 8</span><br><span class="line">5 - 3 = 2</span><br><span class="line">5 - 3 = 15</span><br><span class="line">sn@Program:~/桌面/Test$ </span><br></pre></td></tr></table></figure>
<p>可以看到程序正常运行</p>
</li>
<li>
<p>移动程序位置测试</p>
<p>接下来我们移动 test 程序和库文件的相对位置，再次运行，输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sn@Program:~/桌面$ ./test </span><br><span class="line">请输入两个整数：4 6</span><br><span class="line">4 + 6 = 10</span><br><span class="line">4 - 6 = -2</span><br><span class="line">4 - 6 = 24</span><br><span class="line">sn@Program:~/桌面$ </span><br></pre></td></tr></table></figure>
<p>程序正常运行</p>
</li>
<li>
<p>删除库文件测试</p>
<p>接下来我们删除掉库文件，再次运行，输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sn@Program:~/桌面$ ./test </span><br><span class="line">请输入两个整数：7 8</span><br><span class="line">7 + 8 = 15</span><br><span class="line">7 - 8 = -1</span><br><span class="line">7 - 8 = 56</span><br><span class="line">sn@Program:~/桌面$ </span><br></pre></td></tr></table></figure>
<p>程序正常运行</p>
</li>
</ul>
</li>
</ul>
<h4 id="3）结论">3）结论</h4>
<p>在静态链接库的生成阶段，需要两类文件，一是接口头文件，二是所有的实现源文件，然后才能生成静态链接库文件；</p>
<p>对于只依赖静态链接库的程序来说，在编译之前我们需要两个文件：接口头文件和静态库文件，在编译之后，我们就不再需要这两个文件，编译得到的可执行程序就是一个完整的，可独立执行的一个可执行程序。</p>
<h3 id="3-动态链接库的生成与使用">3. 动态链接库的生成与使用</h3>
<h4 id="1）生成-2">1）生成</h4>
<ul>
<li>
<p>所需文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── add_minus.c</span><br><span class="line">├── multi.c</span><br><span class="line">└── simple.h</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>操作</p>
<ul>
<li>
<p>首先生成接口实现的可重定向目标文件：通过 gcc 命令的 -c 选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c -fpic add_minus.c multi.c</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>生成动态库文件：通过 gcc 命令的 -shared 和 -fpic 选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -shared -fpic add_minus.o multi.o -o libsimple.so</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li><code>-shared</code>：指定我们要生成的目标是一个动态链接库</li>
<li><code>fpic</code>（还可写成 <code>fPIC</code>）：表示各目标文件中函数、类等功能模块的地址使用相对地址</li>
<li><code>-o</code>：指定生成的动态库的名字</li>
</ul>
</li>
<li>
<p>或者将上面两个命令替换成下面这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -shared -fpic add_minus.c multi.c -o libsimple.so</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>于是我们得到了<code>libsimple.so</code>这个动态链接库</p>
</li>
</ul>
</li>
</ul>
<h4 id="2）使用-2">2）使用</h4>
<p>现在，当前目录的文件应该如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── add_minus.c</span><br><span class="line">├── add_minus.o</span><br><span class="line">├── libsimple.so</span><br><span class="line">├── multi.c</span><br><span class="line">├── multi.o</span><br><span class="line">└── simple.h</span><br></pre></td></tr></table></figure>
<p>同样为了模拟实际工程使用第三方动态链接库的情况，我们只拿出两个文件并添加一个测试文件，然后目录应该如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── libsimple.so</span><br><span class="line">├── simple.h</span><br><span class="line">└── test.c</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>操作</p>
<ul>
<li>
<p>和静态链接库类似，直接执行下面的命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc test.c libsimple.so -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>执行测试</p>
<ul>
<li>
<p>正常测试</p>
<p>首先执行命令：<code>./test</code>，得到的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sn@Program:~/桌面/Test$ ./test </span><br><span class="line">./test: error while loading shared libraries: libsimple.so: cannot open shared object file: No such file or directory</span><br><span class="line">sn@Program:~/桌面/Test$ </span><br></pre></td></tr></table></figure>
<p>得到了一个错误，错误是找不到动态链接库的位置，这是因为程序会从默认的库路径寻找，但是我们的库现在不在默认的路径中，解决方法有下面几种：</p>
<ul>
<li>将链接库文件移动到标准库目录下（例如：<code>/usr/lib</code>、<code>usr/lib64</code>、<code>/lib</code>、<code>/lib64</code>）</li>
<li>在终端输入：<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:XXX</code>，<code>XXX</code>为动态链接库文件的绝对存储路径。（该方法仅在当前终端有效）</li>
<li>修改<code>~/.bashrc</code>或<code>~/.bash_profile</code>文件，在最后一行添加：<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:XXX</code>，保存之后执行<code>source bashrc</code>指令即可（此方式仅对当前登陆用户有效）</li>
</ul>
<p>我们采用第二种方案，然后重新执行程序，得到的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sn@Program:~/桌面/Test$ ./test </span><br><span class="line">请输入两个整数：3 5</span><br><span class="line">3 + 5 = 8</span><br><span class="line">3 - 5 = -2</span><br><span class="line">3 - 5 = 15</span><br><span class="line">sn@Program:~/桌面/Test$ </span><br></pre></td></tr></table></figure>
<p>程序正常运行。</p>
</li>
<li>
<p>移动程序位置测试</p>
<p>首先我们调整库文件和可执行程序的相对位置，然后执行程序（不重启终端），得到的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sn@Program:~/桌面$ ./test </span><br><span class="line">请输入两个整数：6 7</span><br><span class="line">6 + 7 = 13</span><br><span class="line">6 - 7 = -1</span><br><span class="line">6 - 7 = 42</span><br><span class="line">sn@Program:~/桌面$ </span><br></pre></td></tr></table></figure>
<p>程序正常运行。</p>
<p><strong>注意</strong>：由于我们设置的是绝对位置，所以更改两个文件之间的相对位置意义不大，如果设置的是相对位置，那么只要更改二者的相对位置，程序应该是无法正常运行的。</p>
</li>
<li>
<p>删除库测试</p>
<p>在我们刚才还能正常运行程序的前提下，不调整目录，直接删除库文件（不重启终端），然后执行程序，得到的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sn@Program:~/桌面$ ./test </span><br><span class="line">./test: error while loading shared libraries: libsimple.so: cannot open shared object file: No such file or directory</span><br><span class="line">sn@Program:~/桌面$ </span><br></pre></td></tr></table></figure>
<p>程序运行失败。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3）总结">3）总结</h4>
<p>在动态链接库的生成阶段，需要两类文件，和静态链接库相同，一是接口头文件，二是接口实现文件。</p>
<p>对于依赖动态链接库的程序来说，在编译之前，需要接口头文件和动态链接库文件；在编译之后，不再需要接口头文件，但是仍然需要动态链接库文件，并且在程序运行之前，还需要设置好库的查找路径程序才能正常运行。</p>
<h2 id="四、-链接库的生成与使用（Windows）">四、 链接库的生成与使用（Windows）</h2>
<h3 id="1-文件（动态库）">1. 文件（动态库）</h3>
<p>对于静态库来说，在 Windows 下使用的文件内容和 Linux 下的相同，但是对于动态库，相关的文件（接口和实现）都需要做一些改动，具体改动如下所示：</p>
<ul>
<li>
<p>首先是头文件，在 Windows 下使用动态库时在生成阶段和使用阶段使用的接口头文件都有区别，具体区别如下：</p>
<ul>
<li>
<p>生成阶段（实现代码用的头文件）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* simple.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数加法</span></span><br><span class="line">_declspec(dllexport) <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数减法</span></span><br><span class="line">_declspec(dllexport) <span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数乘法</span></span><br><span class="line">_declspec(dllexport) <span class="type">int</span> <span class="title function_">multi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用阶段（测试代码用的头文件）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* simple.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数加法</span></span><br><span class="line">_declspec(dllimport) <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数减法</span></span><br><span class="line">_declspec(dllimport) <span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数乘法</span></span><br><span class="line">_declspec(dllimport) <span class="type">int</span> <span class="title function_">multi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意</strong>：看上去在 Windows 下使用动态库比较麻烦，开发者需要提供两个不同的头文件在不同阶段使用，但是实际上可以使用下面的方法将二者合并为同一个头文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* simple.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_API _declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_API _declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数加法</span></span><br><span class="line">DLL_API <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数减法</span></span><br><span class="line">DLL_API <span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数乘法</span></span><br><span class="line">DLL_API <span class="type">int</span> <span class="title function_">multi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>
<p>这样只要在实现代码中定义宏<code>EXPORT</code>就能使用导出时的<code>dllexport</code>，而测试代码中不定义这个宏，就使用<code>dllimport</code></p>
</li>
<li>
<p>实现代码在使用了上面的头文件后，就需要在文件中定义宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* add_minus.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;simple.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* multi.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;simple.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><strong>宏替换</strong>：</p>
<p>宏可以干的事有很多，特别是在提升文件的兼容这一方面贡献很大。通过宏替换，我们还可以将上面的文件改造成兼容 Windows 和 Linux 系统的文件，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* simple.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_API _declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_API _declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_API</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数加法</span></span><br><span class="line">DLL_API <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数减法</span></span><br><span class="line">DLL_API <span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数乘法</span></span><br><span class="line">DLL_API <span class="type">int</span> <span class="title function_">multi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-静态链接库的生成与使用-2">2. 静态链接库的生成与使用</h3>
<p>在 Windows 下生成静态链接库使用的文件与 Linux 中的相同，准备好文件之后就开始下面的步骤吧：</p>
<h4 id="1）新建项目">1）新建项目</h4>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/01.png" alt="01"></p>
<p>我们选择静态库项目，点击下一步，然后设置好项目名和解决方案名称以及路径即可创建完成，创建好后的项目目录如下图所示：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/02.png" alt="02"></p>
<p>当然，实际上这个过滤器并不是真正的文件夹，实际上所有的文件还是在同一个项目文件夹中，这样的话实现代码的包含路径是没有问题的。但是你也可以像我这样存放文件，如下图所示，我将接口头文件放在 include 文件夹中，而实现代码放在 src 文件夹中，而 simple 就是项目文件夹，在里面现在应该没有任何源文件和头文件，我们进入到 IDE 中，右键单击项目，找到添加-现有项就可以把这些文件添加进来。</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/03.png" alt="03"></p>
<p>分成这样的文件夹之后，实现代码中的头文件包含路径就会出错，有两种解决办法，一是修改实现代码中的头文件路径，第二种方法如下所示：</p>
<p>我们首先右键单击项目名，进入到项目属性配置：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/04.png" alt="04"></p>
<p>然后按照下图所示添加包含目录：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/05.png" alt="05"></p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/06.png" alt="06"></p>
<p>包含目录的值最好使用相对地址，<code>SolutionDir</code>就是一个相对地址，在右侧的宏以及值可以看到这个相对地址的绝对值，然后我们在左侧输入这个相对地址并加上我们需要包含的目录的文件夹名称即可，我们可以下方的“计算的值”中看到这个相对地址的绝对值是什么，如下图所示：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/07.png" alt="07"></p>
<p>现在文件包含的问题就解决了。</p>
<h4 id="2）生成静态库">2）生成静态库</h4>
<ul>
<li>
<p>我们先尝试生成解决方案</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/08.png" alt="08"></p>
<p>其输出如下</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/09.png" alt="09"></p>
<p>发现有错，这是因为 VS 默认有一个开关是开着的，我们去把它关掉即可</p>
</li>
<li>
<p>排错</p>
<p>首先进入到项目属性页，找到下面这一项，设置为不使用预编译头即可</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/10.png" alt="10"></p>
<p>我们再生成试试</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/11.png" alt="11"></p>
<p>这就成功了</p>
</li>
<li>
<p>我们去生成目录看看，里面有如下一些文件，其中后缀<code>.lib</code>的文件就是我们需要的静态库文件</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/12.png" alt="12"></p>
</li>
</ul>
<h4 id="3）使用">3）使用</h4>
<p>在 Windows 中有两种使用库的情况，分别是库项目为当前项目的子项目的情况和使用第三方库的情况，在动态库中也是这样，所以下面我们分开说明。</p>
<div class="tabs" id="lib_use_windows"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#lib_use_windows-1">库项目为子项目</button></li><li class="tab"><button type="button" data-href="#lib_use_windows-2">使用第三方库</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="lib_use_windows-1"><p><strong>生成可执行程序</strong>：</p>
<p>首先我们在当前解决方案中添加一个控制台项目，如下图：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/13.png" alt="13"></p>
<p>添加完成之后的解决方案目录如下图：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/14.png" alt="14"></p>
<p>其中的 test.c 文件就是我们一直用的测试文件</p>
<p>我们跟之前一样需要先调整一下该项目的附加包含目录</p>
<p>接下来我们直接尝试生成可执行文件，点击生成解决方案，输出如下：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/15.png" alt="15"></p>
<p>首先有一个关于 scanf 的错误，这是因为在 VS 中它认为这个函数是不安全的，但这暂时对我们没有影响，所以我们先去项目属性设置页面把这一项关掉，具体操作如下：</p>
<p>打开 test 项目的属性页设置找到下图所示的这一项设置关闭即可。</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/16.png" alt="16"></p>
<p>我们尝试生成，输出如下：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/17.png" alt="17"></p>
<p>显示链接错误，这是因为我们根本没有设置 test 的依赖项，因为静态库是我们的一个子项目，所以我们直接设置依赖即可，具体方法就是在 test 项目的引用处右键添加引用即可，如下图所示：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/18.png" alt="18"></p>
<p>然后我们把 simple 项目添加到引用中：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/19.png" alt="19"></p>
<p>确定即可。</p>
<p>接下来我们再来尝试一下生成，输出如下：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/20.png" alt="20"></p>
<p>这一次就生成成功了，可以看到我们的生成目录下已经生成了，一个是我们的子项目的库文件，一个是我们的可执行程序，因为添加了依赖，所以 VS 在生成好库文件之后已经自动帮我们链接好了，所以才能生成我们需要的可执行程序。</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/21.png" alt="21"></p>
<p><strong>测试</strong>：</p>
<ul>
<li>
<p>正常测试</p>
<p>我们直接双击 test.exe 程序，可以看到程序能够启动</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/22.png" alt="22"></p>
<p>输入两个数测试一下</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/23.png" alt="23"></p>
<p>程序正常运行</p>
</li>
<li>
<p>移动位置测试</p>
<p>接下来我们移动 test.exe 和 simple.lib 的相对位置，双击测试</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/24.png" alt="24"></p>
<p>同样正常运行</p>
</li>
<li>
<p>删除库测试</p>
<p>同样的，我们再将库删除后进行测试</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/25.png" alt="25"></p>
<p>依然没问题。</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="lib_use_windows-2"><p><strong>生成可执行程序</strong>：</p>
<p>在上一次测试中，我们将接口头文件和生成的库文件拿出来备用。</p>
<p>然后我们打开 VS 新建一个控制台项目（同时是新建一个解决方案），然后我们在解决方案的文件夹下创建两个文件夹：include 和 lib，前者存放接口头文件，后者存放第三方库文件，同时，我们将测试代码放到项目文件夹下：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/26.png" alt="26"></p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/27.png" alt="27"></p>
<p>然后在 IDE 中通过添加-现有项把我们的项目直接相关的文件添加进去即可：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/28.png" alt="28"></p>
<p>首先我们跟之前一样，调整一下项目的附加包含目录，以及关闭安全检查</p>
<p>我们生成一下，得到的输出如下：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/29.png" alt="29"></p>
<p>同样是链接错误，但是这次我们不是在项目的引用中进行添加，因为这次的库不是我们的子项目，具体的操作方法如下：</p>
<p>打开项目配置页，首先配置链接库的附加包含目录：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/30.png" alt="30"></p>
<p>在里面的输入方法和添加头文件的附加包含目录的方法相同，由于我们需要链接的库在 lib 文件夹下，所以我们应该填写<code>$(SolutionDir)lib</code></p>
<p>然后还没结束，我们还应该让 IDE 知道我们我们这一个项目具体需要链接的是哪一个库，首先打开下图这一项配置：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/31.png" alt="31"></p>
<p>然后将需要链接的库填进去：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/32.png" alt="32"></p>
<p>然后就可以了，我们再生成试一下</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/33.png" alt="33"></p>
<p>这次就成功了。</p>
<p><strong>测试</strong>：</p>
<p>这一块就不用多说了，和之前的结果是一样的，我们直接执行删除库文件之后的可执行程序，程序运行结果如下：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/34.png" alt="34"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="3-动态链接库的生成与使用-2">3. 动态链接库的生成与使用</h3>
<p>首先文件方面，我们需要使用本节内容开始时修改后的几个文件</p>
<h4 id="1）新建项目-2">1）新建项目</h4>
<p>创建项目时选择动态链接库，其他和之前一样：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/35.png" alt="35"></p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/36.png" alt="36"></p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/37.png" alt="37"></p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/38.png" alt="38"></p>
<h4 id="2）生成动态库">2）生成动态库</h4>
<p>我们首先跟之前一样先解决掉头文件包含的问题并且关掉预编译头，然后直接生成即可，输出如下：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/39.png" alt="39"></p>
<p>生成成功，我们去生成目录看看，应该有下面这些文件生成了：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/40.png" alt="40"></p>
<p><code>.dll</code>文件应该是都有的，但有些人可能会没有<code>.lib</code>文件，这大概是因为你没有修改需要使用的文件（导出时头文件需要添加<code>_declspec(dllexport)</code>或者直接使用宏替换后的头文件）</p>
<h4 id="3）使用-2">3）使用</h4>
<div class="tabs" id="dll_use_windows"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dll_use_windows-1">库项目为子项目</button></li><li class="tab"><button type="button" data-href="#dll_use_windows-2">使用第三方库</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dll_use_windows-1"><p><strong>生成可执行程序</strong>：</p>
<p>和静态库时相同，我们新建控制台项目，创建好之后项目结构如下：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/41.png" alt="41"></p>
<p>同样，我们先解决掉新项目的头文件包含路径并关掉安全检查（因为我们要使用 scanf ）</p>
<p>接下来生成一下，不用怀疑肯定有链接错误</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/42.png" alt="42"></p>
<p>由于是子项目，所以和之前一样，我们在 test 项目添加引用就行了，然后就可以正常生成了：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/43.png" alt="43"></p>
<p>我们去生成目录看看，里面的文件如下图所示：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/44.png" alt="44"></p>
<p><strong>测试</strong>：</p>
<ul>
<li>
<p>正常测试</p>
<p>我们直接双击运行，结果如下：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/45.png" alt="45"></p>
<p>程序正常运行</p>
</li>
<li>
<p>改变相对位置和删除库文件测试</p>
<p>这两种结果都是一样的</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/46.png" alt="46"></p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dll_use_windows-2"><p><strong>生成可执行程序</strong>：</p>
<p>同样，我们直接新建控制台项目，文件位置如下所示：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/47.png" alt="47"></p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/48.png" alt="48"></p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/49.png" alt="49"></p>
<p>需要注意的是，在生成可执行文件的时候实际上并不需要<code>.dll</code>文件，我们只需要这个<code>.lib</code>导入库（请牢记这并非静态库）文件</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/50.png" alt="50"></p>
<p>同样的还是添加头文件的附加包含目录并禁用安全检查，然后接下来生成：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/51.png" alt="51"></p>
<p>毫无疑问的链接错误，同样，由于是第三方库，我们不在引用处添加依赖，首先添加链接库的地址，然后说明该项目具体依赖的库，如下图所示：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/52.png" alt="52"></p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/53.png" alt="53"></p>
<p>再次生成</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/54.png" alt="54"></p>
<p>成功。</p>
<p>我们先尝试运行一下，程序报错：</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/55.png" alt="55"></p>
<p>这是因为这次动态库不是我们的项目，IDE 无法自动生成动态库文件到我们的生成目录，我们去生成目录看看</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/56.png" alt="56"></p>
<p>发现只有一个可执行程序，没有动态库</p>
<p>我们把需要的动态库文件从<code>dll</code>目录下拿过来即可</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/57.png" alt="57"></p>
<p><strong>测试</strong>：</p>
<p>双击运行</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/58.png" alt="58"></p>
<p>正常运行。</p>
<p>至于修改两个文件的相对位置这一点我想已经不用再测试了，我们刚刚实际上已经测试过了。</p>
<p>而删除库的测试就更不用说了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="4-总结">4. 总结</h3>
<p>在 Windows 下的链接库的生成与使用过程大概如下：</p>
<ul>
<li>静态库
<ul>
<li>生成
<ul>
<li><code>.lib</code>静态库文件</li>
</ul>
</li>
<li>使用
<ul>
<li>自建子项目：在需要添加依赖的项目的引用处添加对应的引用即可</li>
<li>第三方库
<ul>
<li>提供者：需要提供<code>.lib</code>静态库文件和<code>.h</code>接口头文件</li>
<li>使用者：包含头文件后，设置链接路径并说明需要链接的库</li>
</ul>
</li>
</ul>
</li>
<li>运行
<ul>
<li>不需要任何的其他文件，可执行文件可独立运行</li>
</ul>
</li>
</ul>
</li>
<li>动态库
<ul>
<li>生成
<ul>
<li><code>.dll</code>动态库文件</li>
<li><code>.lib</code>导入库文件</li>
</ul>
</li>
<li>使用
<ul>
<li>自建子项目：在需要添加依赖的项目的引用处添加对应的引用即可</li>
<li>第三方库
<ul>
<li>提供者：需要提供<code>.lib</code>导入库文件和<code>.h</code>接口头文件（注意实现代码和测试代码使用的是两个不同的头文件，或使用宏替换的同一个头文件）供生成时使用，以及一个<code>.dll</code>动态库文件供运行时使用</li>
<li>使用者：包含头文件后，设置<code>.lib</code>导入库的链接路径并说明需要链接的库</li>
</ul>
</li>
</ul>
</li>
<li>运行
<ul>
<li><code>.dll</code>文件必须在系统查找路径或者可执行程序相同路径下</li>
<li>可执行文件执行时<code>.dll</code>文件必须存在且满足上一条条件</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>Windows部分内容主要参考B站up主<a href="https://space.bilibili.com/356450253?spm_id_from=333.999.0.0">喜欢运动衫的帅帅</a>的视频<a href="https://www.bilibili.com/video/BV1S541137P2/?spm_id_from=333.999.0.0&amp;vd_source=3953a33d0f1fdc5decf88b52f7e0d13b">【已完结】Visual Studio工程实践开发(C++)</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>共享库</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>C/C++</tag>
        <tag>库文件</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云服务器网站搭建</title>
    <url>//posts/149af73d/</url>
    <content><![CDATA[<div class="note primary flat"><p>本教程基于LAMP结构搭建Web服务，且在本文中仅演示其中’L’（Linux）和’A’（Apache）的部分，也就是仅仅只是静态网站的搭建教程。</p>
</div>
<div class="note warning flat"><p>我所选择的用于演示的服务器是阿里云的一个 ECS 云服务器，地址在香港，所以不用备案域名就可以直接解析到该服务器；我所选择的服务器的系统是阿里巴巴针对云服务器所定制的一个 Linux 系统，版本号是：Alibaba Cloud Linux 3.2104 LTS 64位。如果你选用其他的系统，可能在下面介绍的一些细节的操作上存在一些区别，请自行判断。</p>
</div>
<div class="note info flat"><p>另外，由于这篇文章基本上是以我自己的几个网站作为案例写下来的，所以肯定不可能适合所有人，所以如果发现我的例子不太适合你的情况，如果不太确定自己应该怎么做，请一定去找更准确的教程。</p>
</div>
<hr>
<h2 id="一、-前期准备">一、 前期准备</h2>
<h3 id="1-添加-80-端口访问">1. 添加 80 端口访问</h3>
<div class="note primary flat"><p>我所使用的这个系统默认是不开防火墙的，也就是从外部就可以访问服务器所有的端口，这样肯定是不安全的，阿里云用了另外一种方式来管理服务器的入流量的允许端口，也就是安全组。由于Web应用默认使用 80 端口，如果是https则默认使用 443 端口，所以如果要搭建Web应用，最好是开启这两个端口，如果开启其他端口，在访问时还需要在域名后指定端口号，访问比较麻烦。</p>
</div>
<ul>
<li>
<p>购买好服务器后，我们需要首先来到 <strong>ECS控制台</strong>的<strong>安全组部分</strong>：</p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/01.png" alt="01"></p>
</li>
<li>
<p>我们点击红框标出来的<strong>配置规则</strong>，然后进入到下面的界面：</p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/02.png" alt="02"></p>
</li>
<li>
<p>直接选择快速添加，将 80 端口添加即可。</p>
</li>
</ul>
<h3 id="2-连接服务器">2. 连接服务器</h3>
<p>要连接到阿里云的服务器有两种方法，一种是直接通过阿里云提供的网络工具连接，另一种是直接从系统使用 ssh 连接。</p>
<div class="tabs" id="ssh_connect"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ssh_connect-1">阿里云网络工具连接服务器</button></li><li class="tab"><button type="button" data-href="#ssh_connect-2">使用本地ssh连接到服务器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ssh_connect-1"><p>我们进入到 <strong>ECS控制台</strong> 并进入到实例管理页面，然后直接点击<strong>远程连接</strong>按钮即可：</p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/04.png" alt="04"></p>
<p>在弹出的窗口里直接选择<strong>立即登录</strong>即可：</p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/05.png" alt="05"></p>
<p>然后就可以输入密码登陆了。</p>
<p>由于我的服务器地址在香港，本地 ssh 连接会容易断线，所以后续的演示我们将使用该方法连接服务器。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ssh_connect-2"><p><strong>基本使用</strong>：</p>
<p>现在不管是 Windows 还是 Linux 几乎都已经内置了 ssh 工具，可以直接从命令行使用 ssh 命令连接，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh User@HostName</span><br></pre></td></tr></table></figure>
<p>即可连接到我们的服务器，接下来输入密码进入即可。在上面的命令中，<code>User</code>就是你将要登陆的服务器的用户名，而<code>HostName</code>就是你的服务器主机名，也就是阿里云给你的服务器的公网 IP，具体的使用如下：</p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/03.png" alt="03"></p>
<p>其中<code>root</code>就是我要登录的用户名，而后面的 IP 地址就是主机名。</p>
<p>回车之后，首先会询问你是否继续连接，我们选择<code>yes</code>。接着就会问你该服务器下登录用户的密码，这里输入之后并不会出现任何可视字符，不用担心你没有输进去。</p>
<p>然后回车我们就进入了该服务器。</p>
<p><strong>取消登录密码验证</strong>：</p>
<p>每一次登录服务器都需要输入密码，这是理所当然的，但如果有一种不用输入密码也能保证安全的方法，那肯定更好。刚好 ssh 就有这样的功能。</p>
<p>我们首先执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;Name&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中<code>&quot;Name&quot;</code>的部分随你喜好填写一个可以标识你身份或你的电脑的名字就行了。</p>
<p>执行命令之后，它会问你是否修改保存密钥文件的地址，我们默认就行。然后它会让你输入密码，但是这个密码我们可以不输入，即为空，然后确认密码即可。</p>
<p>然后，我们就能在当前用户文件夹下的<code>.ssh</code>文件夹下找到两个文件，一个是<code>id_rsa</code>，一个是<code>id_rsa.pub</code>。其中，前者是你电脑的私钥，不能给别人的，而后者是你电脑的公钥，把它交给你想要连接的远程主机即可实现使用密钥对连接而不需要输入密码。</p>
<p>将公钥交给远程主机的具体行为是将公钥的内容写入到远程主机的<code>.ssh/authorized_keys</code>文件中，实现该操作的方法在 Linux 和 Windows 下又有不同：</p>
<ul>
<li>
<p>Linux</p>
<p>我们直接执行下面的命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id User@HostName</span><br></pre></td></tr></table></figure>
<p>它会自动将你的公钥添加到远程主机的<code>authorized_keys</code>文件中。</p>
</li>
<li>
<p>Windows</p>
<blockquote>
<p>如果在Windows上有Git Bash之类的终端也可以像Linux一样操作</p>
</blockquote>
<p>由于在 Windows 中并没有<code>ssh-copy-id</code>命令，所以我们需要使用一些其他的方法，这里只介绍其中一种。</p>
<p>首先我们执行下面的命令将公钥文件传输到远程主机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp C:\Users\YourName\.ssh\id_rsa.pub User@HostName:~/</span><br></pre></td></tr></table></figure>
<p>其中<code>C:\Users\YourName\</code>就是你的用户文件夹，把<code>YourName</code>改为你的用户名即可。</p>
<p>然后先连接到你的远程主机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh User@HostName</span><br></pre></td></tr></table></figure>
<p>然后再将刚刚传输过去的文件的内容写入到<code>authorized_keys</code>文件中即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> id_rsa.pub &gt;&gt; .ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>操作完成后删除我们之前传输的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>然后就 OK 了。</p>
</li>
</ul>
<p>之后我们再从本地连接到服务器就不需要输入密码了。</p>
<p><strong>设置别名</strong>：</p>
<p>如果每一次登录都需要输入登录用户和主机名的话还是会比较麻烦，我们可以通过下面的方法来为服务器设置别名。</p>
<p>首先进入到我们刚刚创建密钥所在的<code>.ssh</code>文件夹中，新建一个<code>config</code>文件，注意没有任何后缀名。</p>
<p>然后我们往<code>config</code>里添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host Alias</span><br><span class="line">	HostName 127.0.0.1</span><br><span class="line">	User root</span><br></pre></td></tr></table></figure>
<p>其中<code>Alias</code>就是你的服务器的别名，然后在下面<code>HostName</code>后填上你的服务器的主机名即可（就是公网 IP，我这里填了一个 localhost 的地址代替），最后是<code>User</code>的值就是你要登陆的用户名。</p>
<p>在这样设置完成之后就可以使用下面的命令直接进入服务器了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh Alias</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="二、-安装使用-Apache">二、 安装使用 Apache</h2>
<h3 id="1-安装">1. 安装</h3>
<p>直接使用下面的命令安装即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install httpd</span><br></pre></td></tr></table></figure>
<p>httpd 就是 Apache 的 Web 服务端程序。</p>
<h3 id="2-重要目录">2. 重要目录</h3>
<p>安装好 Apache 之后，有两个比较重要的目录，我们后续的操作基本上都涉及这两个目录：</p>
<div class="tabs" id="important_dir"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#important_dir-1">/etc/httpd/</button></li><li class="tab"><button type="button" data-href="#important_dir-2">/var/www/</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="important_dir-1"><p>在这个目录下，主要包括<code>conf</code>目录、<code>conf.d</code>目录以及<code>conf.modules.d</code>目录。在<code>conf</code>目录下的<code>httpd.conf</code>文件是 Apache 的主要配置文件，当我们运行 httpd 命令时，它就会读取该配置文件。</p>
<p>而<code>conf.d</code>目录下的配置文件可以用于补充<code>httpd.conf</code>，但如果在<code>httpd.conf</code>文件中包含了这些文件，就相当于把这些子配置文件的内容写入到<code>httpd.conf</code>文件中。对于<code>conf.modules.d</code>目录下的配置文件也是一样。</p>
<p>在功能上，<code>conf.d</code>的配置文件主要用于补充<code>httpd.conf</code>的配置，而<code>conf.modules.d</code>下的配置文件主要用于添加某个模块。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="important_dir-2"><p>在这个目录下是 Apache 默认保存网页文件的地方，它有一个叫做<code>html</code>的目录，你可以把自己的网站文件全部放在这里面，运行 Apache 就直接能访问你的网页了。但我们之后会通过 Git 来拉取仓库，所以不用这个文件夹。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="3-认识-Apache-的配置文件">3. 认识 Apache 的配置文件</h3>
<p>我们用 vim 打开<code>httpd.conf</code>文件，可以看到里面有下面这些比较主要的内容：</p>
<div class="tabs" id="apache_config_file"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#apache_config_file-1">配置文件根目录</button></li><li class="tab"><button type="button" data-href="#apache_config_file-2">监听端口</button></li><li class="tab"><button type="button" data-href="#apache_config_file-3">包含目录</button></li><li class="tab"><button type="button" data-href="#apache_config_file-4">域名配置</button></li><li class="tab"><button type="button" data-href="#apache_config_file-5">网页文件根目录</button></li><li class="tab"><button type="button" data-href="#apache_config_file-6">主页文件名设置</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="apache_config_file-1"><p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/06.png" alt="06"></p>
<p>这就是我们刚刚所说的最重要的其中一个目录，它表示服务器将从这个目录下读取配置文件。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="apache_config_file-2"><p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/07.png" alt="07"></p>
<p>这个配置表示使用 Apache 监听 80 端口，也就是 http 协议的默认端口，我们所有通过域名访问的操作都将默认使用 80 端口访问服务器。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="apache_config_file-3"><p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/08.png" alt="08"></p>
<p>这一行内容表示将包含所有<code>conf.modules.d</code>目录下的所有<code>.conf</code>配置文件。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="apache_config_file-4"><p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/09.png" alt="09"></p>
<p>可以看到这一行配置默认是被注释掉了的，它用来配置我们访问并解析到该服务器的域名。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="apache_config_file-5"><p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/10.png" alt="10"></p>
<p>这一段内容就是用来指示网页文件的位置以及权限的了，其中<code>DocumentRoot</code>后面的路径表示网站主页文件所在的位置，一般是<code>index.html</code>所在的位置。</p>
<p><code>&lt;Directory &quot;/var/www&quot;&gt;</code>标签对以及其中的内容用来定义该目录下服务器所拥有的权限。</p>
<p><code>&lt;Directory &quot;/var/www/html&quot;</code>标签对就是用来定义你的网站主页文件所在目录的权限了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="apache_config_file-6"><p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/11.png" alt="11"></p>
<p>这一条配置是用来描述 Apache 默认查找哪个文件作为网站的主页文件的，你可以在<code>index.html</code>后面添加一个如<code>test.html</code>，它所实现的效果就是如果在你所指定的<code>DocumentRoot</code>下找不到<code>index.html</code>文件的话，就寻找<code>test.html</code>文件作为网站的主页</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="三、-搭建网站">三、 搭建网站</h2>
<p>认识了最基本的 Apache 配置之后，我们开始搭建网站。在修改各种配置之前我们先将网页文件拉下来以及配置好相应的环境。</p>
<p>我这里有三个网站，他们的仓库名分别是：<code>Syunn</code>、<code>Blog</code>、<code>Note</code>。我们首先演示只搭建一个网站的配置方法，用<code>Syunn</code>作为示例。然后我们将演示搭建多个网站的配置方法，此时三个仓库都将作为示例。</p>
<p>其中<code>Blog</code>是用<code>hexo</code>进行构建的，所以我们除了<code>git</code>之外还需要<code>hexo</code>，当然要运行和下载<code>hexo</code>，那也少不了<code>nodejs</code>和<code>npm</code>。</p>
<h3 id="1-准备">1. 准备</h3>
<h4 id="1）git">1）git</h4>
<p>安装 git 很简单：<code>yum install git</code>即可</p>
<p>然后就是配置<code>ssh</code>密钥和<code>git</code>配置：</p>
<p>通过下面的命令创建密钥对：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;Server&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后通过<code>vim</code>打开<code>id_rsa.pub</code>文件，复制其中的内容。然后打开<code>github</code>网站的<code>setting</code>下的<code>SSH and GPG keys</code>处，点击新建 SSH key，取好名字，将复制的内容填入下面的文本框即可。</p>
<p>然后使用下面的命令测试一下 ssh 连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果正常说明已经能够正常连接。</p>
<p>最后配置一下<code>git</code>即可完成<code>git</code>的安装了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;&lt;你的用户名&gt;&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;&lt;你的邮箱&gt;&quot;</span></span><br><span class="line">git config --global core.quotepath <span class="literal">false</span>		/* 解决中文路径显示乱码的问题 */</span><br></pre></td></tr></table></figure>
<p>当然，这些配置写不写都无所谓，因为在服务器这个不太适合编程的环境下，我们通常只需要进行<code>git pull</code>操作。</p>
<h4 id="2）nodejs">2）nodejs</h4>
<blockquote>
<p>由于我的博客是用 hexo 搭建的，所以需要使用 nodejs，如果你不需要就不用安装。</p>
</blockquote>
<p>安装<code>nodejs</code>同样：<code>yum install nodejs</code></p>
<p>然后测试一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>如果都正常显示版本号，则安装成功</p>
<p>因为是在服务器上使用<code>npm</code>，所以实际上换不换源都无所谓，阿里云提供的服务器下行速度都还是又稳又快。</p>
<p>然后安装我需要的<code>hexo</code>即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p>正常显示即可。</p>
<h3 id="2-单网站搭建">2. 单网站搭建</h3>
<h4 id="1）准备">1）准备</h4>
<p>我们首先通过<code>git</code>将<code>Syunn</code>文件夹拉取到<code>/var/www/</code>目录下；</p>
<h4 id="2）修改配置文件">2）修改配置文件</h4>
<p>将原本的<code>httpd.conf</code>文件做一个备份，以便日后恢复：<code>cp /etc/httpd/conf/httpd.conf /etc/httpd/conf/httpd.conf.backup</code></p>
<p>然后我们通过<code>vim</code>打开<code>httpd.conf</code>文件：<code>vim /etc/httpd/conf/httpd.conf</code></p>
<p>在我们之前介绍的配置文件内容的基础上，我们需要修改的内容有以下几点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改域名</span></span><br><span class="line">ServerName syunn.cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改网站根目录</span></span><br><span class="line">DocumentRoot <span class="string">&quot;/var/www/Syunn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以及网站根目录的权限处同样也要修改</span></span><br><span class="line"><span class="comment"># 原本是 &lt;Directory &quot;/var/www/html&quot;&gt;</span></span><br><span class="line"><span class="comment"># 变为</span></span><br><span class="line">&lt;Directory <span class="string">&quot;/var/www/Syunn&quot;</span>&gt;</span><br><span class="line">	<span class="comment"># 中间内容不变</span></span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>
<p>就这么简单就 OK 了。</p>
<h4 id="3）运行-Apache">3）运行 Apache</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start httpd</span><br></pre></td></tr></table></figure>
<p>在运行之前实际上要先去将自己的域名解析到这个 IP 地址，才可以通过域名访问，我已经提前弄好了，直接就可以看到效果了：</p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/12.png" alt="12"></p>
<h3 id="3-多网站搭建">3. 多网站搭建</h3>
<h4 id="1）准备-2">1）准备</h4>
<p>我希望我的博客能用子域名<code>blog.syunn.cn</code>访问以及我的笔记能用<code>note.syunn.cn</code>访问，而不是使用子目录的形式访问。</p>
<p>Apache 的虚拟主机功能为这个问题提供了很好的解决方案。</p>
<p>实际上这个功能用起来非常的简单，只需要往<code>httpd.conf</code>文件里添加几段内容即可。为了模块化该配置文件，我们可以将虚拟主机的功能配置写在其他配置文件中，然后用<code>httpd.conf</code>包含该文件即可。</p>
<p>在修改配置之前，我们先将此次演示需要的两个文件夹<code>Blog</code>和<code>Note</code>拉取到<code>/var/www</code>中即可，然后在<code>Blog</code>文件夹中执行<code>npm install</code>和<code>hexo g -d</code>命令即可完成网页文件的生成。</p>
<h4 id="2）修改配置文件-2">2）修改配置文件</h4>
<p>首先我们在<code>conf.d</code>目录下添加一个新的配置文件，文件名随意取因为那并不是决定性因素，我们就暂定为<code>virtual.conf</code>。</p>
<p>然后通过<code>vim</code>打开该文件，添加下面的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先针对多出来的两个可浏览目录进行权限方面的规范，我们之前的 Syunn 那个目录在 httpd.conf 里已经配置过了</span></span><br><span class="line"><span class="comment"># Blog 的网页文件生成在 public 子目录下</span></span><br><span class="line">&lt;Directory <span class="string">&quot;/var/www/Blog/public&quot;</span>&gt;</span><br><span class="line">	AllowOverride None</span><br><span class="line">	Order allow,deny</span><br><span class="line">	Allow from all</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">&lt;Directory <span class="string">&quot;/var/www/Note&quot;</span>&gt;</span><br><span class="line">	AllowOverride None</span><br><span class="line">	Order allow,deny</span><br><span class="line">	Allow from all</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对三台主机的 DocumentRoot 进行设置</span></span><br><span class="line"><span class="comment"># *:80 表示所有对该服务器的 80 端口访问</span></span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">	ServerName syunn.cn</span><br><span class="line">	<span class="comment"># 设置别名，我希望 www.syunn.cn 可以和使用 syunn.cn 达到同样的效果</span></span><br><span class="line">	ServerAlias www.syunn.cn</span><br><span class="line">	DocumentRoot /var/www/Syunn</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">	ServerName blog.syunn.cn</span><br><span class="line">	DocumentRoot /var/www/Blog/public</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">	ServerName note.syunn.cn</span><br><span class="line">	DocumentRoot /var/www/Note</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意以下几点：</p>
<ul>
<li>在虚拟主机的设置上还有很多可用的功能，不过，最低的限度是需要有<code>ServerName</code>和<code>DocumentRoot</code>这两个</li>
<li>在配置目录权限时使用到的配置项不做解释，请自行去查一查权威的用法</li>
<li>使用了虚拟主机后，原本的主机名（<code>syunn.cn</code>）也要同时写入虚拟主机的对应中，否则这个主机名可能会不知道被丢到哪里去</li>
</ul>
<p>然后，我们需要在<code>httpd.conf</code>文件中包含该文件，可以选择只包含这一个文件，也可以包含<code>conf.d</code>这整个文件夹，我选择的是包含整个文件夹。</p>
<p>在实际的操作中，我选择将这个包含配置写在包含<code>conf.modules.d</code>目录的配置项下面，这样更加的清晰：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Include conf.modules.d/*.conf</span><br><span class="line"><span class="comment"># 第一行是原文件中有的</span></span><br><span class="line"><span class="comment"># 下面是我添加的</span></span><br><span class="line">Include conf.d/*.conf</span><br></pre></td></tr></table></figure>
<p>在<code>httpd.conf</code>文件的末尾实际上还有一条：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IncludeOptional conf.d/*.conf</span><br></pre></td></tr></table></figure>
<p>我们现在可以将它删掉了。</p>
<h4 id="3）重启-Apache">3）重启 Apache</h4>
<p>这些都弄好之后我们就可以重启 Apache 了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart httpd</span><br></pre></td></tr></table></figure>
<p>重启完成之后我们就可以使用三个域名分别打开三个网站了：</p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/14.png" alt="14"></p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/15.png" alt="15"></p>
<h2 id="四、-使用-https">四、 使用 https</h2>
<h3 id="1-前言">1. 前言</h3>
<p>要使用 https 首先需要的一个东西就是 ssl 证书，这个证书说好拿也好拿，说不好拿也不好拿。</p>
<p>首先你可以自制一个自签名的证书，这很轻松，但不幸的是，经过多次测试这样的证书大部分浏览器都不认。</p>
<p>那么就只能去获取一个 CA 认证的证书了，但这些证书不是贵就是弄起来麻烦，所以在写这篇博客之前我一直都只使用<code>http</code>协议。</p>
<p>但在今天我找到了一个可以轻松白嫖且轻松搭建的方法。</p>
<h3 id="2-准备">2. 准备</h3>
<h4 id="1）获取经过认证的免费证书">1）获取经过认证的免费证书</h4>
<p>我们首先进入到阿里云的 ssl 证书购买界面：</p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/16.png" alt="16"></p>
<p>我们首先就直接叉掉这个购买页面，然后来到红框标注的<strong>免费证书</strong>这一栏：</p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/17.png" alt="17"></p>
<p>我们直接点击<strong>立即购买</strong>即可。需要注意的是免费证书一年只能购买 20 个，每个证书只能用于一个具体的域名，不能用于泛域名如<code>*.syunn.cn</code>（对我来说足够了）。另外这些证书有效期为 1 年，但是 1 年之后又可以重新免费获取 20 个的额度（简直不要太爽）。</p>
<h4 id="2）创建证书">2）创建证书</h4>
<p>我们购买好之后可以看见在刚刚的<strong>立即购买</strong>按钮旁边的<strong>创建证书按钮</strong>后面多了一个<code>20/20</code>，也就是我们还可以创建 20 个证书，我们直接点击创建。</p>
<p>需要注意的是创建后的 ssl 证书还需要申请 CA 认证以及域名绑定：</p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/18.png" alt="18"></p>
<p>我们点击<strong>证书申请</strong>即可，在申请页面需要填写绑定的域名（注意只能是单域名如<code>syunn.cn</code>、<code>blog.syunn.cn</code>，不能是泛域名如<code>*.syunn.cn</code>），然后一般首次申请还需要添加联系人，即申请完成后会通过该渠道发信息给你。最后还有一个所在地填写，正常填写即可。</p>
<p>最后点击<strong>提交审核</strong>然后等待审核完成就可以了，这个时间很快，一般两三分钟就可以了，已经审核的 ssl 证书如下所示：</p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/19.png" alt="19"></p>
<p>然后按照同样的操作为我们的三个域名都创建一个证书就可以了，其中<code>syunn.cn</code>只需要创建一个，因为默认该证书将同时用于<code>www.syunn.cn</code>。</p>
<h4 id="3）添加-443-端口访问">3）添加 443 端口访问</h4>
<p>创建好证书之后我们先不着急部署，我们先按照和添加 80 端口同样的方法将 443 端口的访问权限开通即可。</p>
<p>443 端口就是 https 协议的默认传输端口，这里我就不再介绍具体的过程了。</p>
<h3 id="3-部署-SSL-证书">3. 部署 SSL 证书</h3>
<p>阿里云提供的证书有一个一键部署的功能，但由于抽象程度比较高，操作者不太清楚其中做了什么，而且也容易出错，所以我们使用更具体的部署方法。</p>
<h4 id="1）安装-mod-ssl">1）安装 mod_ssl</h4>
<p>我们首先需要安装<code>mod_ssl</code>模块，Apache 才能启用 https 功能。</p>
<p>安装命令：<code>yum install mod_ssl</code></p>
<p>安装好之后有一个非常重要的文件：<code>/etc/httpd/conf.d/ssl.conf</code>，该文件为 ssl 功能的配置文件，我们主要修改这个文件</p>
<p>在修改之前我们还是先认识一下<code>ssl.conf</code>配置文件里的内容：</p>
<div class="tabs" id="ssl_file"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ssl_file-1">监听端口</button></li><li class="tab"><button type="button" data-href="#ssl_file-2">虚拟主机配置</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ssl_file-1"><p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/21.png" alt="21"></p>
<p>首先第一条配置就是先开启监听 443 端口。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ssl_file-2"><p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/22.png" alt="22"></p>
<p>然后就是一个标签对，这个标签对里的内容也是我们等会重点修改的内容，同时在搭建另外两个网站时还会新建两个标签对，就和创建虚拟主机时的操作类似。</p>
<p>可以看到里面也有<code>DocumentRoot</code>和<code>ServerName</code>等内容，这些虽然看上去我们在<code>virtual.conf</code>配置文件里已经配置过了，但那是监听的 80 端口，而这是监听的 443 端口。也就是说，如果我们访问：<code>http://syunn.cn</code>就将进入<code>virtual.conf</code>这个配置文件，而如果访问：<code>https://syunn.cn</code>就将进入<code>ssl.conf</code>这个配置文件。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h4 id="2）下载证书">2）下载证书</h4>
<p>在创建好的证书的后面有一个<strong>下载</strong>按钮，我们点击就会弹出下面的界面：</p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/20.png" alt="20"></p>
<p>由于我们是使用的 Apache 搭建的服务，所以我们选择下载 Apache 的证书。</p>
<p>同时在<strong>下载</strong>按钮前还有一个<strong>帮助</strong>按钮，这里提供了最新的部署方法，也是可以参考的。</p>
<p>点击<strong>下载</strong>之后它会将证书的压缩包下载到本地，我们可以将其先解压然后通过和把<code>id_rsa.pub</code>文件传输到服务器上一样的方法将解压出来的证书传输到服务器，也可以直接将压缩包通过该方法传输到服务器，然后在服务器上安装<code>zip</code>工具通过<code>unzip</code>命令解压压缩包即可。安装命令：<code>yum install zip</code></p>
<p>由于一个域名将有多个证书文件，所以我的建议是在<code>/etc/httpd/</code>目录下建立一个<code>certs</code>目录，然后再按照域名来建立相应的子目录，将对应的证书内容放在对应的子目录下，这样不容易产生混乱。</p>
<h4 id="3）修改配置文件">3）修改配置文件</h4>
<p>以配置<code>syunn.cn</code>为例，我们首先通过<code>vim</code>打开<code>/etc/httpd/conf.d/ssl.conf</code>文件，需要修改的有以下内容（有些配置项本身是被注释了的，直接删除<code>#</code>即可取消注释）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先将标签中的 _default_ 改为 *，如下所示：</span></span><br><span class="line">&lt;VirtualHost *:443&gt;</span><br><span class="line">	ServerName syunn.cn</span><br><span class="line">	ServerAlias www.syunn.cn</span><br><span class="line">	DocumentRoot /var/www/Syunn</span><br><span class="line">	</span><br><span class="line">	SSLEngine on</span><br><span class="line">	</span><br><span class="line">	SSLProtocol all -SSLv2 -SSLv3</span><br><span class="line">	</span><br><span class="line">	SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM</span><br><span class="line">	SSLHonorCipherOrder on</span><br><span class="line">	<span class="comment"># 以_public.crt 结尾的那个文件</span></span><br><span class="line">	SSLCertificateFile /etc/httpd/certs/syunn/syunn.cn_public.crt</span><br><span class="line">	<span class="comment"># 以 .key 结尾的那个文件</span></span><br><span class="line">	SSLCertificateKeyFile /etc/httpd/certs/syunn/syunn.cn.key</span><br><span class="line">	<span class="comment"># 以 _chain.crt 结尾的那个文件</span></span><br><span class="line">	SSLCertificateChainFile /etc/httpd/certs/syunn/syunn.cn_chain.crt</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 其他未涉及到的内容不做修改</span></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<p>如果想要添加其他的域名，就添加一对<code>&lt;VirtualHost *:443&gt;</code>标签对然后在里面把上面所涉及到的内容添加到标签对里面即可。</p>
<p><strong>需要注意的是</strong>，新添加的<code>VirtualHost</code>标签对一定要在前一个<code>VirtualHost</code>标签对之外，注意不要看错了，因为在默认的那个<code>VirtualHost</code>标签对中还有其他标签对。</p>
<p>大概的内容都已经涉及到了，这里就不再演示添加其他域名的操作了。</p>
<p>添加完成后还需要确认在<code>httpd.conf</code>文件中有没有包含这个文件，由于我们之前添加包含时直接添加了整个目录，所以可以确定是包含了的。</p>
<h4 id="4）将-http-访问转发到-https">4）将 http 访问转发到 https</h4>
<p>我们可以强制所有对网站的访问都是 https 访问。具体做法是修改之前的监听 80 端口的那个虚拟主机配置文件。</p>
<p>我们首先通过<code>vim</code>打开该文件，在这个文件里，我们设置了三个虚拟主机，分别代理三个域名，如果我们需要某个域名强制使用 https 访问，就在该虚拟主机的标签对里添加下面的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond %&#123;SERVER_PORT&#125; !^443$</span><br><span class="line">RewriteRule ^(.*)$ https://%&#123;SERVER_NAME&#125;<span class="variable">$1</span> [L,R]</span><br></pre></td></tr></table></figure>
<p><code>Rewrite</code>是一个重写配置，它使用正则表达式进行配置，上面的配置的含义就是当监听到 http 访问时就转发到对应的 https 访问。</p>
<h4 id="5）重启-Apache">5）重启 Apache</h4>
<p>按照之前的操作将 Apache 服务重启一次即可。</p>
<p>可以看到，在地址栏旁边已经不再是**“不安全”**的提示了，已经可以使用 https 访问了：</p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/23.png" alt="23"></p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/24.png" alt="24"></p>
<p><img src="/images/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/25.png" alt="25"></p>
<hr>
]]></content>
      <categories>
        <category>网络</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Linux</tag>
        <tag>网站</tag>
        <tag>阿里云</tag>
        <tag>服务器</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
</search>
