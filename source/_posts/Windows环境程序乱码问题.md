---
title: Windows环境程序乱码问题
date: 2023-07-18 00:00:00
updated: 2023-07-20 00:00:00
tags:
  - 系统
  - Windows
  - 字符集
categories:
  - Windows
  - 字符集
description: 主要关于Windows环境下编程乱码问题的讨论，以及已知解决方案与测试
top_img:  /img/cover/material-5.webp
cover:  /img/cover/material-5.webp
abbrlink: b8fb1066
---

## 一、 前言

### 1. 问题描述

作为非英语国家的Windows用户，在Windows上进行编程想必都会遇到一个问题：中文乱码的问题。当然不只是中文，还有其他很多非英文国家也都有这个问题，这里仅以中文为例。

另外，乱码还有很多种类型，如常见的“锟斤拷”、“火星文”乱码等，它们的引发原因都是不同的。以及程序运行时还分为输入乱码以及输出乱码。我将对其进行详细的讨论。



### 2. 目标

程序是程序员写的，是写给用户用的。我们需要抓住这里面的两个主要对象：

- 用户：用户只想要以最轻松的方法就能正常使用软件，就像我们使用软件时只需要打开一个exe文件就可以了，一切复杂的操作都不要留给用户。

  > 这里一定要说的是：网络上有很多方法可以解决乱码问题，比如将Windows调成Beta版、终端在运行前通过chcp修改代码页或者是去注册表里修改终端的代码页属性等，这些工作做了确实有一定的效果（甚至有些效果都不完全），但是有哪个用户希望在使用你这个软件的时候去改这改那的，甚至还会影响到其他软件的运行。

- 程序员：只想以最小的工作量完成需要的功能。

  > 为了解决乱码问题，我们当然可以将源文件就直接保存为GBK编码，然后编译的时候也按照GBK编译，最后的程序运行在GBK终端上，这样的方式当然是可以解决乱码问题，但是这样的程序只能给默认使用GBK编码的Windows系统的用户使用。为了使软件走向国际化，你还得为每一个有特殊代码页的国家编译一次甚至还得修改代码，最后让用户来选自己应该下载哪一个版本。这样既麻烦了程序员，又为用户带来了不必要的麻烦。
  >
  > 为了解决这个问题，我们可以使用Unicode编码，它可以表示全世界正在使用的所有字符并且还有空余位置。其中 UTF-8 编码应用最广，因为在所有Unicode编码中，只有UTF-8保证了除了空字符外，其余字符都不含0字节（这对使用C语言编程的程序比较友好，因为C语言程序通常以0字节表示字符串终止，如果在其他字符中包含0字节，可想而知，程序会将其自动识别为已终止，但实际上内容还没完）。

综上所述，我们最主要的一个目标就是如何编写一个UTF-8编码的程序并让其在任何终端环境都能正常运行。



### 3. 测试程序

我们的测试代码如下：

```c
#include <stdio.h>

int main(void)
{
    char name[20];
    
    scanf("%s", name);
    printf("你刚刚的输入是：%s\n", name);
    
    return 0;
}
```

这个程序中既涉及到了输入，也涉及到了输出，我们可以同时测试两种类型的乱码，并根据乱码的类型来判断原因。



### 4. 影响因素

在从源文件到软件程序的过程中，有几个因素都会影响最终程序的乱码与否，我们通过两个编译器来看比较典型的两个过程：

#### 1）MSVC编译器

这是Visual Studio配套的一个编译器，如果不做任何修改，它的一个编译过程如下：

![01]( /images/Windows环境程序乱码问题/01.jpg)

其运行结果如下：

![02]( /images/Windows环境程序乱码问题/02.png)

所以在默认情况下，我们使用Visual Studio生成的程序可以完美地在自己的机器上执行。但由于其产生的目标程序使用GBK编码，而我们并不希望如此。



#### 2）GCC编译器

除了MSVC是默认使用GBK编码源文件之外，其他编译器基本上都是使用的UTF-8编码，不一定是GCC，但它比较有代表性，其典型过程如下图所示：

![03]( /images/Windows环境程序乱码问题/03.jpg)

其运行结果如下：

![04]( /images/Windows环境程序乱码问题/04.png)



#### 3）总结

从这上面的两个例子我们可以看到以下几点：

- 对于中文**输入**来说，程序的编码与终端的编码是否相同对结果并没有什么影响，这是因为程序只保存编码后的字节信息，然后输出时将字节信息发送给终端，中间并不会经过什么处理。如果我们要在程序中处理中文字符，一般就不使用`char`来保存字符信息了，而使用宽字符。
- 源文件编码、编译器编码以及程序运行的终端这三个方面的共同作用会决定最后的程序是否会出现乱码。



### 5. 配置 Visual Studio（可选）

回过头来看我们想要达到的目标，使用UTF-8编码编写程序，生成的程序中使用UTF-8编码保存字符及字符串，最后能在任何编码环境的终端上正确运行。

很显然，上面的第二种过程（GCC）比较适合我们要讨论的内容（虽然它的输出暂时有问题），后面也将主要使用这种方法来进行测试。但对于第一种过程（MSVC）也是可以调整成与第二种过程相同的。

对于仅开发面向于使用GBK编码的Windows用户的程序来说，当然使用其原本的配置就可以了，生成的程序也能完美的在这样的主机上运行。但如果是想使用UTF-8编码或者有软件国际化需求的程序员来说，也可以像下面这样将MSVC配置成与GCC编译（编码上）相同的过程：

#### 1）保证文件的编码

我们首先需要做的就是保证文件的编码是UTF-8编码。

- 第一步是开启查看当前的文件的编码的设置项

  主要目标是开启【文件】菜单栏下的【高级保存选项】的选项。以下是操作过程（过程比较多就不用截图的方式了）：

  【工具】->【自定义】->【命令】-> 在【菜单栏】右侧的下拉框中选择【文件】->【添加命令】->【文件】-> 在右侧找到【高级保存选项】-> 点击【确定】即可添加

  > 开启该功能后就可以在【文件】菜单栏下找到【高级保存选项】了，将文件打开并进入编辑状态就可以打开该选项，就可以看到该文件的编码了。
  >
  > 通常在新建项目时，Visual Studio自动创建的文件都是UTF-8编码的，而自己新建的文件都是GBK编码的。

- 接下来是强制将文件按照UTF-8进行保存

  在这一步我们需要去下载一个插件，叫做 “Force UTF-8 (With BOM) 2022” 或者 “Force UTF-8 (No BOM) 2022”，这两者都可以，区别在于第一个会在文件前面添加签名标识文件的编码。

  安装好并重启软件之后它就开始生效了。我们新创建一个文件，这时去查看它的编码应该仍然是GBK编码，我们点击一下保存，然后将文件叉掉再重新打开就可以看到它已经变成UTF-8编码了



#### 2）更改MSVC的编码

这一步完成之后，使用MSVC的过程就和使用GCC的过程（在编码上）基本一致了，其具体操作如下：

打开【项目属性】->【配置属性】->【C/C++】->【命令行】-> 在【其他选项】中输入`/utf-8` ->【确定】/【应用】即可



#### 3）测试

测试结果如下：

![05]( /images/Windows环境程序乱码问题/05.png)

可以看到，其输出结果和GCC过程相同了。



## 二、 分析、方法及测试

### 1. 分析

#### 1）乱码的决定性环节

我们需要分析的是，在文件、编译器、终端这三者之间，哪些的编码可以一致。

- 首先是三者都相同，也就是默认状态下的MSVC的过程，虽然源文件可以是其他编码，但它最后会被MSVC转换成GBK编码

- 其次是二者相同的情况

  - 如果文件和编译器相同，那么可执行程序中的字符及字符串按照源文件编码保存，当终端编码与前二者不同时，将会产生乱码
  - 如果编译器和终端相同，那么源文件的字符及字符串被解释为另一种编码，但二进制内容还是不变。然后按照被解释的编码进行输出，结果显然是乱码。
  - 如果文件和终端相同（假设都为GBK），那么可执行程序中的字符在源文件中是GBK，而经过了编译器的转换，现在是UTF-8编码，但是虽然二者的解释不同，但是它们的内容还是一样的，所以当使用GBK编码的终端执行程序时，可执行程序中的UTF-8编码又被解释回了GBK编码，于是程序能够正常输出并且正常输入。

  **综上所述，实际上最终是否有乱码并不受编译器编码的影响，而只取决于源文件与终端二者的编码是否一致。**

- 最后是三者都不同的情况，根据我们刚才的结论，很明显这个会出现乱码



#### 2）确定方向

根据上面所得出的结论，我们要做的就是让源文件编码和终端编码相同，而我们的目标是编写UTF-8程序并在所有环境的终端上都能正常运行。

所以很显然，我们的源文件应该是UTF-8编码的，而终端则可以是任何编码的。显然在这种情况下如果我们什么都不做，那么最终结果一定会出现乱码。

为了解决这个矛盾，我能想到的唯一（同时不麻烦用户）的办法就是**在程序中插入代码改变运行环境**。



#### 3）终端输入输出编码不统一

根据上面的改进方向看上去很容易可以完成这样的修改，网上也有很多这样的方法，比如`chcp 65001`之类的方法。但使用`chcp`来修改终端代码页的方法经测试只能修改其输出编码，但是输入编码仍然是GBK，然后最后通过终端输出时又成了UTF-8编码，从而导致输入的回显乱码。

这也导致Windows终端编码的问题异常的难以解决。



### 2. 测试准备

#### 1）测试代码

基本上还是上面的代码，不过经过了细微的修改：

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char name[20] = { 0 };
    
    scanf("%s", name);
    printf("你的输入是：%s\n", name);
    printf("输入字符数：%d\n", strlen(name));
    
    return 0;
}
```

主要是添加了一条语句计算输入字符串的长度，这条语句的本意是为了判断程序是否成功读取了内容，而不是真的为了计算输入的字符数量，毕竟汉字也不是单个字节。加上这一条的原因是在后面的测试中，有时会无法读取，为了判断是否刚好是空白乱码，所以添加了这样一句。



#### 2）乱码类型及原因

如下表所示：

| 乱码类型 | 示例                                         | 产生原因                                                     |
| -------- | -------------------------------------------- | ------------------------------------------------------------ |
| 古文码   | 鐢辨湀瑕佸ソ濂藉涔犲ぉ澶╁悜涓?              | 以GBK的方式读取UTF-8编码的中文                               |
| 口字码   | ����Ҫ�¨²�ѧϰ������                            | 以UTF-8的方式读取GBK编码的中文                               |
| 符号码   | ç”±æœˆè¦�å¥½å¥½å­¦ä¹ å¤©å¤©å�‘ä¸Š            | 以ISO8859-1方式读取UTF-8编码的中文                           |
| 拼音码   | ÓÉÔÂÒªºÃºÃÑ§Ï°ÌìÌìÏòÉÏ                       | 以ISO8859-1方式读取GBK编码的中文                             |
| 问句码   | 由月要好好学习天天向??                       | 以GBK方式读取UTF-8编码的中文，<br />然后又用UTF-8的格式再次读取 |
| 锟拷码   | 锟斤拷锟斤拷要锟矫猴拷学习锟斤拷锟斤拷锟斤拷 | 以UTF-8方式读取GBK编码的中文，然后又用GBK的格式再次读取      |



### 2.5. 测试前问题【严重】

我们的改进目标是在源文件中插入代码然后让程序本身在开始运行的时候自发改变运行环境，从而适应不同编码环境的终端，而其自发改变运行环境的最终目标当然是和源文件编码相同即UTF-8编码。

于是我在一个完全UTF-8编码的环境下进行了测试（我搭建了一台Windows虚拟机并在区域设置里调成了Beta版）。在其他环境下，即使通过调整使输出正常了，但输入却老是会出现乱码问题，这主要是源于前面所提到的一些方法只能改变终端的输出编码而导致终端输入输出编码的不同以致于乱码。

我想至少先在完全UTF-8编码的环境下进行测试，如果能正常输入输出，至少证明我们的方向是对的。但非常令人难以接受的是，即使在这样的环境下，程序仍然出错了。这一次不再是乱码错误，而是根本无法接收输入（表面上是这样），并且不论是MinGW还是MSVC编译的程序，效果都一样。

在调试之后，发现了问题所在，在完全UTF-8编码的机器上运行该程序，中文能够正常输出，但是输入的中文却无法正常读取，在调试过程中我发现所有的中文字符都被读取为了空字符（注意并不只有开头是空字符，是整个中文字符都被识别为了空字符，它们只在空字符数量上有区别），即使我将`scanf`函数改为了`fgets`函数，效果也是一样，`name`数组中被覆盖了的字节都是空字符（偶尔会有换行符），从而导致了读取的内容无法正常输入或者说是读取出错。

虽然找到了表面问题所在，但我对解决这个问题的方法却完全没有头绪。当我去问AI的时候，它告诉我可能是因为Windows的运行时库的影响，但没有任何具体的措施去解决。

综上原因，导致我无法确认后续所提出的方法是否达到了正确的效果。所以后续测试中如果出现输入乱码问题，我会对其进行分析；但如果出现输出读取问题，我就无法解释了。



### 3. 方法及测试

{% tabs methods %}

<!-- tab chcp法 -->

- 说明

  先说明，此处的chcp法和我在前言部分提到的chcp法不同，那种方法是用户执行chcp改变终端环境，很明显违背了用户的需求，而且经过实测那一种方法实际上仍然有问题，如我在执行该命令后，再运行程序仍然输出乱码。

- 此处的chcp法是在程序内添加`system`函数来执行该指令，代码如下：

  ```c
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  
  int main(void)
  {
      system("chcp 65001");
      char name[20] = {0};
  
      scanf("%s", name);
      printf("你的输入是：%s\n", name);
      printf("输入字符数：%d\n", strlen(name));
  
      return 0;
  }
  ```

  主要改动是添加了头文件`<stdlib.h>`以及一条`system`函数调用。

- 其运行结果如下：

  ```
  Active code page: 65001
  你好
  你的输入是：��
  输入字符数：2
  ```

- 分析

  根据结果可以看出，其输出正常，但输入出现乱码。输入乱码则首先说明一点，就是终端的输入输出编码不一致，具体的原因根据前面的乱码类型表可以知道是以UTF-8的方式读取了GBK编码的中文。

  输出正常说明输出编码是UTF-8编码，不难猜出输入编码应该还是GBK编码。实际也确实如此，我们输入的中文被终端转换为GBK编码然后原封不动保存到程序，最后程序交给终端这些数据之后，终端又以UTF-8编码输出该字符数据，从而导致以UTF-8的方式读取GBK编码的中文。

- 解决方法

  暂时并没有该问题的（并且满足用户需求的）解决方案，同时也并不建议大家使用这个方法。首先就是因为输入编码与输出不一致的原因；其次如果你只是开发Windows程序的话倒是没什么大问题，但是如果你同时希望程序能够在Linux上编译运行成功，就不能这样做，因为Linux上没有chcp命令，当然也可以在代码中添加条件判断来做兼容，但这样就又会变得麻烦了一点。

<!-- endtab -->

<!-- tab Win32 API法 -->

- 说明

  该方法是使用`<Windows.h>`头文件中的函数来改变终端的环境

- 代码

  ```c
  #define WIN32_LEAN_AND_MEAN
  #define NOMINMAX
  #include <stdio.h>
  #include <string.h>
  #include <Windows.h>
  
  int main(void)
  {
      SetConsoleCP(CP_UTF8);
      SetConsoleOutputCP(CP_UTF8);
      char name[20] = {0};
  
      scanf("%s", name);
      printf("你的输入是：%s\n", name);
      printf("输入字符数：%d\n", strlen(name));
  
      return 0;
  }
  ```

  添加了两个宏、一个头文件以及两条语句。

- 运行结果

  此处运行结果非常奇怪，所有的输入最后都返回同样的乱码，有些甚至不算乱码，也就是一般的字符，但无一例外每次都返回相同的字符，在每一次重新启动终端后，返回的字符会发生变化，甚至有一次还复现了在本部分2.5节所提到的运行结果，或许二者有一定的关联。

  ```
  PS C:\Users\tangc\source\vscode> .\a.exe
  你好
  你的输入是：PP
  输入字符数：2
  PS C:\Users\tangc\source\vscode> .\a.exe
  乱码测试
  你的输入是：PPPP
  输入字符数：4
  ```

  ```
  PS C:\Users\tangc\source\vscode> .\a.exe
  你好
  你的输入是：@@
  输入字符数：2
  PS C:\Users\tangc\source\vscode> .\a.exe
  乱码测试
  你的输入是：@@@@
  输入字符数：4
  ```

  ```
  PS C:\Users\tangc\source\vscode> .\a.exe
  你好
  你的输入是：��
  输入字符数：2
  PS C:\Users\tangc\source\vscode> .\a.exe
  乱码测试
  你的输入是：����
  输入字符数：4
  ```

  ```
  PS C:\Users\tangc\source\vscode> .\a.exe
  你好
  你的输入是：
  输入字符数：0
  PS C:\Users\tangc\source\vscode> .\a.exe
  乱码测试
  你的输入是：
  输入字符数：0
  ```

  大致就是这4种结果，其中最后一种出现的比较少。通常在同一个终端里，一直运行该程序，其输出的字符都是同一种字符，如果重启了终端，则可能会变成另一种输出类型。另外如果开启两个终端交叉执行该程序，在同一个终端里，最后输出的结果也可能发生变化，但无一例外，每个单次输出的结果都是同一个字符。

- 解决方法

  无法分析该结果

<!-- endtab -->

<!-- tab setlocale法 -->

- 说明

  该方法使用标准库中的`setlocale`函数

- 代码

  ```c
  #include <locale.h>
  #include <stdio.h>
  #include <string.h>
  
  int main(void)
  {
      setlocale(LC_ALL, ".utf-8");
      char name[20] = { 0 };
  
      scanf("%s", name);
      printf("你的输入是：%s\n", name);
      printf("输入字符数：%d\n", strlen(name));
  
      return 0;
  }
  ```

  添加了一个头文件及一条语句。

- 输出

  我使用该方法得到的程序也有些问题，首先如果使用MinGW生成的程序，那么`setlocale`不生效，即输出如下：

  ```
  PS C:\Users\tangc\source\vscode> .\a.exe
  你好
  浣犵殑杈撳叆鏄細你好
  杈撳叆瀛楃鏁帮細4
  ```

  而如果使用Visual Studio生成程序，则其得到的结果如下：

  ```
  你好
  你的输入是：输入字符数：4
  ```

  真的是让人匪夷所思，它看上去成功读取了内容，因为最后显示长度为 4，但包含在源代码里的格式它都给我改了，它读取到的内容本身没有输出也就算了，我`printf`里的`\n`也没有输出，难道说读取内容的时候还把内存里的数据给改了？我尝试增加了`name`数组的大小也使用了Windows的`scanf_s`函数，但结果仍然没有任何改变。

- 解决方法

  问题无法分析，解决方法无

<!-- endtab -->

<!-- tab 添加字符转换层功能 -->

该方法与前面三种方法对比，目前算是最靠谱的一种方法，具体的措施就是在程序和用户界面之间添加一层字符转换功能，这样同时也就不用改变用户终端环境，虽然和我们最开始决定的方向有所区别，但确确实实能解决问题，而且事实也证明改变用户终端环境的方法会出现很多问题。

而且第一中方法所得到的输入的字符还会出现一个问题（2、3种方法由于无法分析其输入错误的原因所以不做讨论）：在我们的程序只需要输出，并不会对输入进行回显但是却需要处理用户的中文输入的时候，我们将无法处理，因为我们在程序中将按照uft-8的编码（如果是宽字符，则一般是Unicode编码）进行处理，然而此时我们所获取到的用户输入确实GBK的编码，很显然在处理过程中会出现错误。而这种方法也同时解决了这样的问题。

它的具体过程如下所示：

![06]( /images/Windows环境程序乱码问题/06.jpg)

还是简单做了个测试，过程如下：

- 代码

  ```c
  #include <stdio.h>
  #include <string.h>
  #include "convert.h"
  
  int main(void)
  {
      // 输出字符串定义与转换
      char firstOut_utf8[] = "你输入的是：";      // 定义输出字符串（与源文件编码相同，即utf8）
      char secondOut_utf8[] = "输入字符数：";     //
      char firstOut_gbk[20];                     // 用于保存编码转换后的输出字符串
      char secondOut_gbk[20];                    //
      utf8ToGbk(firstOut_utf8, strlen(firstOut_utf8), firstOut_gbk, 20);
      utf8ToGbk(secondOut_utf8, strlen(secondOut_utf8), secondOut_gbk, 20);
  
      // 输入字符串定义与转换
      char name_gbk[20];
      char name_utf8[20];
      char name_unicode[20];
      char name_gbk2[20];
      scanf("%s", name_gbk);
      gbkToUtf8(name_gbk, strlen(name_gbk), name_utf8, 20);
      multibyteToUnicode(name_utf8, strlen(name_utf8), CP_UTF8, name_unicode, 20);
      unicodeToMultibyte(name_unicode, strlen(name_unicode), name_gbk2, 20, CP_ACP);
  
      printf("%s%s\n", firstOut_gbk, name_gbk2);
      printf("%s%d\n", secondOut_gbk, strlen(name_gbk2));
  
      return 0;
  }
  ```

  在头文件`convert.h`就是几个字符编码转换函数，主要有`utf8ToGbk`、`gbkToUtf8`（提供 UTF-8 和 GBK 之间的转换），以及`multibyteToUnicode`、`unicodeToMultibyte`（提供多字节编码（GBK、UTF-8）与 Unicode 编码之间的转换）。

  在程序中可以看到，在输出字符串部分，我首先是定义了需要直接输出的字符串，然后用转换函数将其从UTF-8转换成了GBK；在输入字符串部分，首先是将获取到的gbk输入转换成`utf8`，再转换成`Unicode`，最后再转换回GBK（看上去是做的无用功，实际上确实也是，在这里主要是更突出一下这个转换函数确实是有作用的）。最后将都转换成GBK编码的字符串输出。

- 结果

  ```
  PS C:\Users\tangc\source\vscode> .\a.exe     
  你好
  你输入的是：你好
  输入字符数：4
  PS C:\Users\tangc\source\vscode> .\a.exe
  乱码测试
  你输入的是：乱码测试
  输入字符数：8
  ```

  非常成功

需要说明的是，这里的测试代码仅仅只是用于测试，包括头文件中的几个函数实际上都是非常不成熟的，毕竟没有人在使用`printf`之前先将需要输出的内容定义好；另外，如果是一个成熟的功能，我认为它至少还应该能够自动识别当前用户字符编码环境，然后提供程序与用户界面之间字符编码的自动转换，这样不仅让用户好用，也让程序员好写。

<!-- endtab -->

{% endtabs %}



## 三、 结论

以上的几种方法是我在网上搜集到的一些方法，它们都能够比较好的解决输出乱码的问题，但是输入回显的乱码问题却仍然得不到解决。

在前三种方法中我原本最看好的是第三种，因为它不依赖与系统，但实际测试中却不知为何MinGW编译出的程序`setlocale`不生效，以及即使使用Visual Studio生成的程序`setlocale`生效了，但它似乎带来了比乱码更麻烦的问题。

第四种方法是当前比较完美的一种解决方案，该方案是在一位B站up主的帮助下获得的启发，已将其B站主页链接在文末。



****

以上内容主要参考了该文章：[记录Windows下开发C/C++如何避免乱码](https://zhuanlan.zhihu.com/p/627531212)

以及非常感谢B站up主[喜欢运动衫的帅帅](https://space.bilibili.com/356450253?spm_id_from=333.999.0.0)的帮助
