---
title: 链接库的生成与使用
date: 2023-02-04 00:00:00
updated: 2023-07-20 00:00:00
tags:
  - 教程
  - 库文件
  - C/C++
categories:
  - C/C++
  - 共享库
description: 关于C/C++生成及使用共享库的教程，分别包括Windows和Linux系统上的操作过程
top_img:  /img/cover/material-3.webp
cover:  /img/cover/material-3.webp
abbrlink: f65fc406
---

## 一、 前言

在实际工程中，生成与使用链接库是比较常用的操作，本文将从以下几个方面来介绍链接库的生成与使用：

- 程序的编译过程：这一部分算是链接库的前提知识，当我们清晰地了解了整个编译过程的实际编译阶段之后，我们才能比较好地了解链接库的工作过程。
- 认识链接库：主要讲解链接库的两个类别：动态链接库和静态链接库，以及它们的工作过程。
- 静态链接库的生成与使用：如题所示，就是讲静态链接库怎么生成使用
- 动态链接库的生成与使用：同上

同时，本文将通过引用的格式写一些对理解有帮助的 tips，这些 tips 有些人可能很清楚，但是有些人根本不了解（比如我），具体的格式就像下面这样：

> **tip**：
>
> ...



## 二、 编译过程

当我们第一次使用 gcc 这个编译器的时候，一般执行的第一个命令就是：`gcc main.c`，它将我们的源文件 `main.c` “编译” 后生成了一个可执行文件：`a.out`（Windows下为`a.exe`）。于是，很多人可能就会有一个误解：编译就一个步骤，即编译本身。

但实际上整个编译过程并非只有一个步骤，而是由以下几个步骤组成：

假设我们有一个程序`main.c`如下所示：

```c
#include <stdio.h>
int main(void)
{
    printf("Hello World!\n");
    
    return;
}
```

然后执行以下命令：`gcc main.c`，然后 gcc 编译器就会执行下面的步骤：

{% tabs Compile_process %}

<!-- tab 预处理-->

该过程将所有的`#define`、`#include`等进行替换。

> **库和头文件的区别**：
>
> 相信很多刚开始学习计算机知识以及刚开始学习 C 语言或 C++ 的小伙伴一定对这两个名词很疑惑，理解起来很混乱。
>
> **头文件**大家都不陌生，能够通过`#include`包含的都算是头文件，但是我们在包含`<stdio.h>`这类标准库的时候，为什么要叫它标准库而不是标准头文件呢。
>
> 了解过面向对象编程的小伙伴都知道我们经常要将类型的接口和实现分离，为的就是对类型进行封装，在不暴露其实现细节的情况下为别人提供服务，而这个封装的方法就是通过库来进行，通过将类型或函数的实现生成为库（这个后面会讲），程序在包含这个头文件之后就看不到具体的实现了，只能看到头文件提供的接口（也就是类型的成员以及提供的函数接口）。
>
> 而标准库就是这么一个东西，我们包含的`<stdio.h>`里面只有它提供的接口，如一些常用的函数`printf`、`scanf`等等，但是这些函数的实现并不在这个头文件里，而在一个叫做 C 语言标准库的库文件里，这个库在整个编译过程的链接阶段会用到。
>
> 而我们包含的`<stdio.h>`只为我们提供接口，预处理的过程就是将这个文件里的内容粘贴到`#include <stdio.h>`所在的位置，相当于为我们的`main.c`提供了`printf`、`scanf`等函数的函数声明，方便我们接下来使用这些函数。

<!-- endtab -->

<!-- tab 编译-->

将预处理之后的`main.c`进行编译过程，这个编译过程通常是根据当前的机器将源文件翻译成对应的汇编程序源文件，用后缀`.s`表示，即`main.c`被翻译为`main.s`，这个文件是汇编语言写成的程序。之所以要进行这一步，是因为在不同的机器上，相同指令的机器代码是不同的。我们使用的 C/C++ 语言则是高度抽象的语言，不因机器而异，但是我们最终得到的可执行程序却与机器相关，所以我们首先需要将其转换成与机器相关的文件。汇编语言是机器码的第一层抽象，也与机器相关，所以我们将 C 语言源文件先翻译成汇编语言源文件，然后再生成可执行文件

<!-- endtab -->

<!-- tab 汇编 -->

也就是将上一步我们得到的汇编语言源文件进行汇编得到一个后缀为`.o`的文件，即`main.o`，这类文件叫做**可重定向目标文件**，这个文件里面已经就是我们的机器将要执行的机器码了，是一个二进制文件，但为什么不是`a.out`或者说是`a.exe`文件呢？因为整个编译过程还有一个阶段没做

<!-- endtab -->

<!-- tab 链接 -->

这一步对于 C/C++ 语言的初学者来说好像基本上遇不到，但实际上你编写的几乎每个程序都有这个过程，因为我们免不了使用标准库提供的函数。如果我们使用非标准库也就是第三方库，那么在 gcc 的命令中需要显式地链接这个库文件，这个库文件里就是我们之前包含的一个只有接口没有实现的头文件的实现部分。而只使用标准库的文件为什么在 gcc 命令中不需要显式地链接呢？其原因就是因为几乎每个程序都需要用到标准库提供的函数，而每一次使用 gcc 命令都要显式链接一下标准库实在太麻烦了，所以 gcc 都是隐式地链接了标准库，就不需要我们再动手链接了。在链接好之后我们就可以得到最终的可执行程序了，即`a.out`或`a.exe`

我们可以在终端执行下面的命令来看一下我们最终得到的可执行程序的依赖，也就是它需要链接的库：

```bash
ldd a.out
```

可以得到下面的输出：

```bash
sn@Program:~/桌面/Test$ ldd a.out 
	linux-vdso.so.1 (0x00007ffd0315f000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd4e1a41000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fd4e1c7d000)
```

`linux-vdso.so.1`和`/lib64/ld-linux-x86-64.so.2`在本文中不涉及，中间的`/lib/x86-64-linux-gnu/libc.so.6`这个文件也就是我们的标准库，里面的内容就是我们使用的标准库函数的实现部分。

<!-- endtab -->

{% endtabs%}



## 三、 认识链接库

### 1. 链接库类型

链接库分为两类：静态链接库和动态链接库

静态链接库用后缀 `.a`（Linux）或 `.lib`（Windows）表示

动态链接库用后缀 `.so`（Linux）或 `.dll`（Windows）表示

接下来我们就来具体认识一下这两种库，整个认识过程将从库的生成到使用以及库的工作过程来说明。

{% tabs libriry %}

<!-- tab 静态链接库 -->

在建立静态链接库之前，我们首先需要写好一些文件：

- 作为接口的头文件
- 接口的实现

然后将以上两类文件处理（处理的具体方法后面会讲）之后，我们就可以得到一个静态链接库（`.a`或`.lib`），然后库的提供者将两份文件提供给库的使用者：

- 接口头文件：是和上面的同一个头文件
- 静态链接库文件：已经将接口的实现部分编译为二进制文件并打包了起来，使用者可以通过链接该文件得到实现的部分。

库的使用者如果要使用这个库，那就需要做两件事：

- 首先包含库的提供者提供的接口头文件：里面只有接口也就是类型、类型成员和函数的声明。包含该文件之后，使用者才能正常使用其提供的类型和函数
- 在编译时需要将库文件加入到命令中

然后在整个编译过程中，gcc 就会做如下工作：

- 预处理：将接口头文件的内容粘贴到包含的地方
- 编译、汇编
- 链接：将使用到的接口头文件中的函数的代码从库文件中复制到可重定向目标文件中

最后就生成了一个可执行文件，在执行过程中，由于所有的代码都已经在可执行文件中了，所以不论库的位置是否变化，或者是否删除该库，这个可执行文件都能正常执行。

<!-- endtab -->

<!-- tab 动态链接库 -->

在建立动态链接库之前，我们需要准备好和静态链接库相同的文件：

- 接口头文件（在 Windows 中这个头文件需要做一些处理）
- 接口的实现

然后将以上两类文件处理之后，我们就可以得到一个动态链接库（`.so`或`.dll`，Windows 下还会生成一个`.lib`作为导入库，注意不是静态库），然后库的提供者将以下文件提供给库的使用者：

- 接口头文件
- 动态链接库文件
- 如果是 Windows 还需要将导入库文件一并给出

库的使用者如果要使用这个库，应该如下操作：

- 包含接口头文件
- 在编译时需要将 动态链接库文件（Linux）或 导入库文件（Windows）加入到命令中

然后在编译过程中，gcc 的工作如下：

- 预处理、编译、汇编
- 链接：将使用到的接口头文件中的函数从库文件中映射一个地址到可重定向目标文件中

最后得到可执行程序，进行执行。在执行过程中，当遇到接口中的函数时，程序就会跳转到对应的动态库中的相应地址进行执行。所以如果动态链接库的位置变动或删除，这个可执行程序都将无法正常运行。

<!-- endtab -->

{% endtabs %}



### 2. 二者的区别

通过上面的介绍，我们不难总结出静态链接库与动态链接库的区别：

{% tabs differences %}

<!-- tab 文件名 -->

静态库的后缀是`.a`或`.lib`

而动态库的后缀是`.so`或`.dll`

<!-- endtab -->

<!-- tab 生成及使用操作 -->

具体内容请见下文

<!-- endtab -->

<!-- tab 链接方式 -->

静态库是将实现代码复制到可执行文件中

动态库是将实现代码的地址映射到可执行文件中

<!-- endtab -->

<!-- tab 目标文件 -->

很显然依赖静态链接库比起依赖动态链接库的程序要更大

<!-- endtab -->

<!-- tab 执行过程 -->

依赖静态库的程序执行过程中不再需要所依赖的库文件

依赖动态库的程序执行过程中需要所依赖的库文件

<!-- endtab -->

{% endtabs %}



### 3. 关于后文

本文将着重说明使用 gcc 生成静态库和动态库的方法以及使用的方法，所以其实是着重说明 Linux 下的生成与使用方法。

在 Windows 下也可以使用 gcc 按照与 Linux 相同的方法使用动态库和静态库，或许有些许的区别。但是这不是正常的 Windows 生成和使用链接库的方法，比如在 Windows 中生成一个动态库应该会生成两个文件，一个`.dll`的动态库文件和一个`.lib`的导入库文件，但是使用 gcc 就值生成一个`.dll`文件。当脱离了标准，使用就会变得困难，比如我如果使用 gcc 生成一个动态库，然后将这个动态库交给别人，那么别人在拿到这个动态库的时候就只有接口头文件和一个`.dll`文件，并没有`.lib`的导入库文件，那么拿到这个库的人如果环境中没有安装 gcc，那么他可能无法正常使用这个动态库。综上所述，我不会讲解在 Windows 下使用 gcc 生成动态库和静态库的方法。

所以后文将分成两部分，一部分是在 Linux 下的链接库的生成与使用方法，使用编译工具 gcc；另一部分是在 Windows 下的链接库的生成与使用方法，使用 Visual Studio IDE，本文不包含该 IDE 的使用方法。



## 四、 链接库的生成与使用（Linux）

### 1. 文件

我将用下面的文件进行演示，为了便于理解，这些函数都很简单。

- 接口头文件：simple.h

  ```c
  /* simple.h */
  
  // 整数加法
  int add(int a, int b);
  
  // 整数减法
  int minus(int a, int b);
  
  // 整数乘法
  int multi(int a, int b);
  ```

- 接口实现：add_minus.c、multi.c

  这里用两个文件进行实现是为了演示多文件编译的过程，正常情况下在一个文件中进行实现即可。

  ```c
  /* add_minus.c */
  
  #include "simple.h"
  
  int add(int a, int b)
  {
      return a + b;
  }
  
  int minus(int a, int b)
  {
      return a - b;
  }
  ```

  ```c
  /* multi.c */
  
  #include "simple.h"
  
  int multi(int a, int b)
  {
      return a * b;
  }
  ```

- 测试文件：test.c

  ```c
  /* test.c */
  
  #include "simple.h"
  #include <stdio.h>
  
  int main(void)
  {
      int a, b;
      printf("请输入两个整数：");
      scanf("%d %d", &a, &b);
      printf("%d + %d = %d\n", a, b, add(a, b));
      printf("%d - %d = %d\n", a, b, minus(a, b));
      printf("%d - %d = %d\n", a, b, multi(a, b));
      
      return 0;
  }
  ```



### 2. 静态链接库的生成与使用

#### 1）生成

- 所需文件

  ```
  ├── add_minus.c
  ├── mutli.c
  └── simple.h
  ```

- 操作

  - 首先将接口实现编译成可重定向目标文件：通过 gcc 的 -c 选项

    ```bash
    gcc -c add_minus.c multi.c
    ```

  - 然后将这些可重定向目标文件打包成静态库：通过 ar 命令

    ```bash
    ar -crv libsimple.a add_minus.o multi.o
    ```

    **注意**：`libsimple.a`是我们需要的静态库的名字，命名规范是：`libXXX.a`，`XXX`是我们自己起的库的名字

  - 于是我们得到了`libsimple.a`这个静态库文件。

#### 2）使用

在生成这一部分完成之后，我们的文件夹应该如下所示：

```bash
├── add_minus.c
├── add_minus.o
├── libsimple.a
├── mutli.c
├── mutli.o
└── simple.h
```

为了模拟实际工程中我们使用第三方静态库的情况，我们只从中抽取出两个文件：simple.h、libsimple.a 并加入一个测试程序源文件 test.c。

- 所需文件

  ```
  ├── libsimple.a
  ├── simple.h
  └── test.c
  ```

- 操作：直接执行下面的命令即可

  ```bash
  gcc test.c libsimple.a -o test
  ```

  **注意**：可以看到我们使用静态库的方法就跟多源文件编译的方法相同，就是把库文件当成一个源进行编译。

  最终生成可执行文件 test

- 执行测试

  - 正常测试

    我们来执行起来看一下：输入命令`./test`，输出如下：

    ```bash
    sn@Program:~/桌面/Test$ ./test 
    请输入两个整数：
    ```

    我们输入两个整数进行测试：

    ```bash
    sn@Program:~/桌面/Test$ ./test 
    请输入两个整数：5 3 
    5 + 3 = 8
    5 - 3 = 2
    5 - 3 = 15
    sn@Program:~/桌面/Test$ 
    ```

    可以看到程序正常运行
    
  - 移动程序位置测试

    接下来我们移动 test 程序和库文件的相对位置，再次运行，输出如下：
  
    ```bash
    sn@Program:~/桌面$ ./test 
    请输入两个整数：4 6
    4 + 6 = 10
    4 - 6 = -2
    4 - 6 = 24
    sn@Program:~/桌面$ 
    ```
    
    程序正常运行
    
  - 删除库文件测试
  
    接下来我们删除掉库文件，再次运行，输出如下：
  
    ```bash
    sn@Program:~/桌面$ ./test 
    请输入两个整数：7 8
    7 + 8 = 15
    7 - 8 = -1
    7 - 8 = 56
    sn@Program:~/桌面$ 
    ```
  
    程序正常运行
  



#### 3）结论

在静态链接库的生成阶段，需要两类文件，一是接口头文件，二是所有的实现源文件，然后才能生成静态链接库文件；

对于只依赖静态链接库的程序来说，在编译之前我们需要两个文件：接口头文件和静态库文件，在编译之后，我们就不再需要这两个文件，编译得到的可执行程序就是一个完整的，可独立执行的一个可执行程序。



### 3. 动态链接库的生成与使用

#### 1）生成

- 所需文件

  ```
  ├── add_minus.c
  ├── multi.c
  └── simple.h
  ```

- 操作

  - 首先生成接口实现的可重定向目标文件：通过 gcc 命令的 -c 选项

    ```bash
    gcc -c -fpic add_minus.c multi.c
    ```

  - 生成动态库文件：通过 gcc 命令的 -shared 和 -fpic 选项

    ```
    gcc -shared -fpic add_minus.o multi.o -o libsimple.so
    ```

    **注意**：

    - `-shared`：指定我们要生成的目标是一个动态链接库
    - `fpic`（还可写成 `fPIC`）：表示各目标文件中函数、类等功能模块的地址使用相对地址
    - `-o`：指定生成的动态库的名字

  - 或者将上面两个命令替换成下面这个命令：

    ```bash
    gcc -shared -fpic add_minus.c multi.c -o libsimple.so
    ```

  - 于是我们得到了`libsimple.so`这个动态链接库

#### 2）使用

现在，当前目录的文件应该如下：

```
├── add_minus.c
├── add_minus.o
├── libsimple.so
├── multi.c
├── multi.o
└── simple.h
```

同样为了模拟实际工程使用第三方动态链接库的情况，我们只拿出两个文件并添加一个测试文件，然后目录应该如下：

```
├── libsimple.so
├── simple.h
└── test.c
```

- 操作

  - 和静态链接库类似，直接执行下面的命令即可：

    ```bash
    gcc test.c libsimple.so -o test
    ```

- 执行测试

  - 正常测试

    首先执行命令：`./test`，得到的输出结果如下：

    ```
    sn@Program:~/桌面/Test$ ./test 
    ./test: error while loading shared libraries: libsimple.so: cannot open shared object file: No such file or directory
    sn@Program:~/桌面/Test$ 
    ```

    得到了一个错误，错误是找不到动态链接库的位置，这是因为程序会从默认的库路径寻找，但是我们的库现在不在默认的路径中，解决方法有下面几种：

    - 将链接库文件移动到标准库目录下（例如：`/usr/lib`、`usr/lib64`、`/lib`、`/lib64`）
    - 在终端输入：`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:XXX`，`XXX`为动态链接库文件的绝对存储路径。（该方法仅在当前终端有效）
    - 修改`~/.bashrc`或`~/.bash_profile`文件，在最后一行添加：`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:XXX`，保存之后执行`source bashrc`指令即可（此方式仅对当前登陆用户有效）

    我们采用第二种方案，然后重新执行程序，得到的输出结果如下：

    ```
    sn@Program:~/桌面/Test$ ./test 
    请输入两个整数：3 5
    3 + 5 = 8
    3 - 5 = -2
    3 - 5 = 15
    sn@Program:~/桌面/Test$ 
    ```

    程序正常运行。

  - 移动程序位置测试

    首先我们调整库文件和可执行程序的相对位置，然后执行程序（不重启终端），得到的输出结果如下：

    ```
    sn@Program:~/桌面$ ./test 
    请输入两个整数：6 7
    6 + 7 = 13
    6 - 7 = -1
    6 - 7 = 42
    sn@Program:~/桌面$ 
    ```

    程序正常运行。

    **注意**：由于我们设置的是绝对位置，所以更改两个文件之间的相对位置意义不大，如果设置的是相对位置，那么只要更改二者的相对位置，程序应该是无法正常运行的。

  - 删除库测试

    在我们刚才还能正常运行程序的前提下，不调整目录，直接删除库文件（不重启终端），然后执行程序，得到的输出结果如下：

    ```
    sn@Program:~/桌面$ ./test 
    ./test: error while loading shared libraries: libsimple.so: cannot open shared object file: No such file or directory
    sn@Program:~/桌面$ 
    ```

    程序运行失败。



#### 3）总结

在动态链接库的生成阶段，需要两类文件，和静态链接库相同，一是接口头文件，二是接口实现文件。

对于依赖动态链接库的程序来说，在编译之前，需要接口头文件和动态链接库文件；在编译之后，不再需要接口头文件，但是仍然需要动态链接库文件，并且在程序运行之前，还需要设置好库的查找路径程序才能正常运行。



## 四、 链接库的生成与使用（Windows）

### 1. 文件（动态库）

对于静态库来说，在 Windows 下使用的文件内容和 Linux 下的相同，但是对于动态库，相关的文件（接口和实现）都需要做一些改动，具体改动如下所示：

- 首先是头文件，在 Windows 下使用动态库时在生成阶段和使用阶段使用的接口头文件都有区别，具体区别如下：

  - 生成阶段（实现代码用的头文件）

    ```c
    /* simple.h */
    
    // 整数加法
    _declspec(dllexport) int add(int a, int b);
    
    // 整数减法
    _declspec(dllexport) int minus(int a, int b);
    
    // 整数乘法
    _declspec(dllexport) int multi(int a, int b);
    ```

  - 使用阶段（测试代码用的头文件）

    ```c
    /* simple.h */
    
    // 整数加法
    _declspec(dllimport) int add(int a, int b);
    
    // 整数减法
    _declspec(dllimport) int minus(int a, int b);
    
    // 整数乘法
    _declspec(dllimport) int multi(int a, int b);
    ```

  **注意**：看上去在 Windows 下使用动态库比较麻烦，开发者需要提供两个不同的头文件在不同阶段使用，但是实际上可以使用下面的方法将二者合并为同一个头文件。

  ```c
  /* simple.h */
  
  #ifdef EXPORT
  #define DLL_API _declspec(dllexport)
  #else
  #define DLL_API _declspec(dllimport)
  #endif
  
  // 整数加法
  DLL_API int add(int a, int b);
  
  // 整数减法
  DLL_API int minus(int a, int b);
  
  // 整数乘法
  DLL_API int multi(int a, int b);
  ```

  这样只要在实现代码中定义宏`EXPORT`就能使用导出时的`dllexport`，而测试代码中不定义这个宏，就使用`dllimport`

- 实现代码在使用了上面的头文件后，就需要在文件中定义宏

  ```c
  /* add_minus.c */
  
  #define EXPORT
  
  #include "simple.h"
  
  int add(int a, int b)
  {
      return a + b;
  }
  
  int minus(int a, int b)
  {
      return a - b;
  }
  ```

  ```c
  /* multi.c */
  
  #define EXPORT
  
  #include "simple.h"
  
  int multi(int a, int b)
  {
      return a * b;
  }
  ```



> **宏替换**：
>
> 宏可以干的事有很多，特别是在提升文件的兼容这一方面贡献很大。通过宏替换，我们还可以将上面的文件改造成兼容 Windows 和 Linux 系统的文件，代码如下：
>
> ```c
> /* simple.h */
> 
> #ifdef WIN32
> #ifdef EXPORT
> #define DLL_API _declspec(dllexport)
> #else
> #define DLL_API _declspec(dllimport)
> #endif
> #else
> #define DLL_API
> #endif
> 
> // 整数加法
> DLL_API int add(int a, int b);
> 
> // 整数减法
> DLL_API int minus(int a, int b);
> 
> // 整数乘法
> DLL_API int multi(int a, int b);
> ```



### 2. 静态链接库的生成与使用

在 Windows 下生成静态链接库使用的文件与 Linux 中的相同，准备好文件之后就开始下面的步骤吧：

#### 1）新建项目

![01]( /images/链接库的生成与使用/01.png)

我们选择静态库项目，点击下一步，然后设置好项目名和解决方案名称以及路径即可创建完成，创建好后的项目目录如下图所示：

![02]( /images/链接库的生成与使用/02.png)

当然，实际上这个过滤器并不是真正的文件夹，实际上所有的文件还是在同一个项目文件夹中，这样的话实现代码的包含路径是没有问题的。但是你也可以像我这样存放文件，如下图所示，我将接口头文件放在 include 文件夹中，而实现代码放在 src 文件夹中，而 simple 就是项目文件夹，在里面现在应该没有任何源文件和头文件，我们进入到 IDE 中，右键单击项目，找到添加-现有项就可以把这些文件添加进来。

![03]( /images/链接库的生成与使用/03.png)

分成这样的文件夹之后，实现代码中的头文件包含路径就会出错，有两种解决办法，一是修改实现代码中的头文件路径，第二种方法如下所示：

我们首先右键单击项目名，进入到项目属性配置：

![04]( /images/链接库的生成与使用/04.png)

然后按照下图所示添加包含目录：

![05]( /images/链接库的生成与使用/05.png)

![06]( /images/链接库的生成与使用/06.png)

包含目录的值最好使用相对地址，`SolutionDir`就是一个相对地址，在右侧的宏以及值可以看到这个相对地址的绝对值，然后我们在左侧输入这个相对地址并加上我们需要包含的目录的文件夹名称即可，我们可以下方的“计算的值”中看到这个相对地址的绝对值是什么，如下图所示：

![07]( /images/链接库的生成与使用/07.png)

现在文件包含的问题就解决了。



#### 2）生成静态库

- 我们先尝试生成解决方案

  ![08]( /images/链接库的生成与使用/08.png)

  其输出如下

  ![09]( /images/链接库的生成与使用/09.png)

  发现有错，这是因为 VS 默认有一个开关是开着的，我们去把它关掉即可

- 排错

  首先进入到项目属性页，找到下面这一项，设置为不使用预编译头即可

  ![10]( /images/链接库的生成与使用/10.png)

  我们再生成试试

  ![11]( /images/链接库的生成与使用/11.png)

  这就成功了

- 我们去生成目录看看，里面有如下一些文件，其中后缀`.lib`的文件就是我们需要的静态库文件

  ![12]( /images/链接库的生成与使用/12.png)

#### 3）使用

在 Windows 中有两种使用库的情况，分别是库项目为当前项目的子项目的情况和使用第三方库的情况，在动态库中也是这样，所以下面我们分开说明。

{% tabs lib_use_Windows %}

<!-- tab 库项目为子项目 -->

**生成可执行程序**：

首先我们在当前解决方案中添加一个控制台项目，如下图：

![13]( /images/链接库的生成与使用/13.png)

添加完成之后的解决方案目录如下图：

![14]( /images/链接库的生成与使用/14.png)

其中的 test.c 文件就是我们一直用的测试文件

我们跟之前一样需要先调整一下该项目的附加包含目录

接下来我们直接尝试生成可执行文件，点击生成解决方案，输出如下：

![15]( /images/链接库的生成与使用/15.png)

首先有一个关于 scanf 的错误，这是因为在 VS 中它认为这个函数是不安全的，但这暂时对我们没有影响，所以我们先去项目属性设置页面把这一项关掉，具体操作如下：

打开 test 项目的属性页设置找到下图所示的这一项设置关闭即可。

![16]( /images/链接库的生成与使用/16.png)

我们尝试生成，输出如下：

![17]( /images/链接库的生成与使用/17.png)

显示链接错误，这是因为我们根本没有设置 test 的依赖项，因为静态库是我们的一个子项目，所以我们直接设置依赖即可，具体方法就是在 test 项目的引用处右键添加引用即可，如下图所示：

![18]( /images/链接库的生成与使用/18.png)

然后我们把 simple 项目添加到引用中：

![19]( /images/链接库的生成与使用/19.png)

确定即可。

接下来我们再来尝试一下生成，输出如下：

![20]( /images/链接库的生成与使用/20.png)

这一次就生成成功了，可以看到我们的生成目录下已经生成了，一个是我们的子项目的库文件，一个是我们的可执行程序，因为添加了依赖，所以 VS 在生成好库文件之后已经自动帮我们链接好了，所以才能生成我们需要的可执行程序。

![21]( /images/链接库的生成与使用/21.png)

**测试**：

- 正常测试

  我们直接双击 test.exe 程序，可以看到程序能够启动

  ![22]( /images/链接库的生成与使用/22.png)

  输入两个数测试一下

  ![23]( /images/链接库的生成与使用/23.png)

  程序正常运行

- 移动位置测试

  接下来我们移动 test.exe 和 simple.lib 的相对位置，双击测试

  ![24]( /images/链接库的生成与使用/24.png)

  同样正常运行

- 删除库测试

  同样的，我们再将库删除后进行测试

  ![25]( /images/链接库的生成与使用/25.png)

  依然没问题。

<!-- endtab -->

<!-- tab 使用第三方库 -->

**生成可执行程序**：

在上一次测试中，我们将接口头文件和生成的库文件拿出来备用。

然后我们打开 VS 新建一个控制台项目（同时是新建一个解决方案），然后我们在解决方案的文件夹下创建两个文件夹：include 和 lib，前者存放接口头文件，后者存放第三方库文件，同时，我们将测试代码放到项目文件夹下：

![26]( /images/链接库的生成与使用/26.png)

![27]( /images/链接库的生成与使用/27.png)

然后在 IDE 中通过添加-现有项把我们的项目直接相关的文件添加进去即可：

![28]( /images/链接库的生成与使用/28.png)

首先我们跟之前一样，调整一下项目的附加包含目录，以及关闭安全检查

我们生成一下，得到的输出如下：

![29]( /images/链接库的生成与使用/29.png)

同样是链接错误，但是这次我们不是在项目的引用中进行添加，因为这次的库不是我们的子项目，具体的操作方法如下：

打开项目配置页，首先配置链接库的附加包含目录：

![30]( /images/链接库的生成与使用/30.png)

在里面的输入方法和添加头文件的附加包含目录的方法相同，由于我们需要链接的库在 lib 文件夹下，所以我们应该填写`$(SolutionDir)lib`

然后还没结束，我们还应该让 IDE 知道我们我们这一个项目具体需要链接的是哪一个库，首先打开下图这一项配置：

![31]( /images/链接库的生成与使用/31.png)

然后将需要链接的库填进去：

![32]( /images/链接库的生成与使用/32.png)

然后就可以了，我们再生成试一下

![33]( /images/链接库的生成与使用/33.png)

这次就成功了。

**测试**：

这一块就不用多说了，和之前的结果是一样的，我们直接执行删除库文件之后的可执行程序，程序运行结果如下：

![34]( /images/链接库的生成与使用/34.png)

<!-- endtab -->

{% endtabs %}



### 3. 动态链接库的生成与使用

首先文件方面，我们需要使用本节内容开始时修改后的几个文件

#### 1）新建项目

创建项目时选择动态链接库，其他和之前一样：

![35]( /images/链接库的生成与使用/35.png)

![36]( /images/链接库的生成与使用/36.png)

![37]( /images/链接库的生成与使用/37.png)

![38]( /images/链接库的生成与使用/38.png)



#### 2）生成动态库

我们首先跟之前一样先解决掉头文件包含的问题并且关掉预编译头，然后直接生成即可，输出如下：

![39]( /images/链接库的生成与使用/39.png)

生成成功，我们去生成目录看看，应该有下面这些文件生成了：

![40]( /images/链接库的生成与使用/40.png)

`.dll`文件应该是都有的，但有些人可能会没有`.lib`文件，这大概是因为你没有修改需要使用的文件（导出时头文件需要添加`_declspec(dllexport)`或者直接使用宏替换后的头文件）



#### 3）使用

{% tabs dll_use_windows %}

<!-- tab 库项目为子项目 -->

**生成可执行程序**：

和静态库时相同，我们新建控制台项目，创建好之后项目结构如下：

![41]( /images/链接库的生成与使用/41.png)

同样，我们先解决掉新项目的头文件包含路径并关掉安全检查（因为我们要使用 scanf ）

接下来生成一下，不用怀疑肯定有链接错误

![42]( /images/链接库的生成与使用/42.png)

由于是子项目，所以和之前一样，我们在 test 项目添加引用就行了，然后就可以正常生成了：

![43]( /images/链接库的生成与使用/43.png)

我们去生成目录看看，里面的文件如下图所示：

![44]( /images/链接库的生成与使用/44.png)

**测试**：

- 正常测试

  我们直接双击运行，结果如下：

  ![45]( /images/链接库的生成与使用/45.png)

  程序正常运行

- 改变相对位置和删除库文件测试

  这两种结果都是一样的

  ![46]( /images/链接库的生成与使用/46.png)

<!-- endtab -->

<!-- tab 使用第三方库 -->

**生成可执行程序**：

同样，我们直接新建控制台项目，文件位置如下所示：

![47]( /images/链接库的生成与使用/47.png)

![48]( /images/链接库的生成与使用/48.png)

![49]( /images/链接库的生成与使用/49.png)

需要注意的是，在生成可执行文件的时候实际上并不需要`.dll`文件，我们只需要这个`.lib`导入库（请牢记这并非静态库）文件

![50]( /images/链接库的生成与使用/50.png)

同样的还是添加头文件的附加包含目录并禁用安全检查，然后接下来生成：

![51]( /images/链接库的生成与使用/51.png)

毫无疑问的链接错误，同样，由于是第三方库，我们不在引用处添加依赖，首先添加链接库的地址，然后说明该项目具体依赖的库，如下图所示：

![52]( /images/链接库的生成与使用/52.png)

![53]( /images/链接库的生成与使用/53.png)

再次生成

![54]( /images/链接库的生成与使用/54.png)

成功。

我们先尝试运行一下，程序报错：

![55]( /images/链接库的生成与使用/55.png)

这是因为这次动态库不是我们的项目，IDE 无法自动生成动态库文件到我们的生成目录，我们去生成目录看看

![56]( /images/链接库的生成与使用/56.png)

发现只有一个可执行程序，没有动态库

我们把需要的动态库文件从`dll`目录下拿过来即可

![57]( /images/链接库的生成与使用/57.png)

**测试**：

双击运行

![58]( /images/链接库的生成与使用/58.png)

正常运行。

至于修改两个文件的相对位置这一点我想已经不用再测试了，我们刚刚实际上已经测试过了。

而删除库的测试就更不用说了。

<!-- endtab -->

{% endtabs %}



### 4. 总结

在 Windows 下的链接库的生成与使用过程大概如下：

- 静态库
  - 生成
    - `.lib`静态库文件
  - 使用
    - 自建子项目：在需要添加依赖的项目的引用处添加对应的引用即可
    - 第三方库
      - 提供者：需要提供`.lib`静态库文件和`.h`接口头文件
      - 使用者：包含头文件后，设置链接路径并说明需要链接的库
  - 运行
    - 不需要任何的其他文件，可执行文件可独立运行
- 动态库
  - 生成
    - `.dll`动态库文件
    - `.lib`导入库文件
  - 使用
    - 自建子项目：在需要添加依赖的项目的引用处添加对应的引用即可
    - 第三方库
      - 提供者：需要提供`.lib`导入库文件和`.h`接口头文件（注意实现代码和测试代码使用的是两个不同的头文件，或使用宏替换的同一个头文件）供生成时使用，以及一个`.dll`动态库文件供运行时使用
      - 使用者：包含头文件后，设置`.lib`导入库的链接路径并说明需要链接的库
  - 运行
    - `.dll`文件必须在系统查找路径或者可执行程序相同路径下
    - 可执行文件执行时`.dll`文件必须存在且满足上一条条件



****

Windows部分内容主要参考B站up主[喜欢运动衫的帅帅](https://space.bilibili.com/356450253?spm_id_from=333.999.0.0)的视频[【已完结】Visual Studio工程实践开发(C++)](https://www.bilibili.com/video/BV1S541137P2/?spm_id_from=333.999.0.0&vd_source=3953a33d0f1fdc5decf88b52f7e0d13b)

